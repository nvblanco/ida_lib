import torch
import numpy as np

data_types_2d = {"image", "mask", "heatmap"}
data_types_1d = {"keypoints"}

def preprocess_data(data, device):
    if device not in ('cpu', 'cuda'):
        raise Exception('Device must be either cpu or cuda')
    result_data = {}
    if isinstance(data, dict):
        types_2d = {}
        compose_data = torch.tensor([])
        for type in data.keys():
            if type in data_types_2d:
                compose_data = torch.cat((compose_data, data[type]), 0)#concatenate data into one multichannel pytoch tensor
                types_2d[type] = data[type].shape[0]
            else:
                points = data[type]
        result_data['data2d'] = compose_data.to(device)
        result_data['types2d'] = types_2d
        if points is not None: result_data['data1d'] = keypoints_to_homogeneus(points)
        return result_data
    else:
        if data.dim() < 3:
            raise Exception("Single data must be al least 3 dims")
        else:
            result_data["data2d"] = data
            return result_data


#converts the intermediate values ​​generated by the transformations to 0-1
def mask_change_to_01(mask):
    for i in range(mask.shape[1]):
        for j in range(mask.shape[2]):
            if mask[0, i, j] < 0.5:
                mask[0, i, j] = 0
            else:
                mask[0, i, j] = 1

def postprocess_data(data):
    if data.keys().__contains__('types2d'):
        data_output = {}
        data_split = torch.split(data['data2d'], list(data['types2d'].values()), dim = 0)
        for index, type in enumerate(data['types2d']):
            data_output[type] = data_split[index]
        data_output['keypoints'] = [(dato[:2,:]).reshape(2) for dato in data['data1d']]
        if data.keys().__contains__('mask'): data_output['mask'] = mask_change_to_01(data_output['mask'])
    else:
        data_output = data['data2d']
    return data_output

def keypoints_to_homogeneus(keypoints):
    if keypoints[0].dim() == 1 : keypoints  = [point.reshape(2,1) for point in keypoints]
    return tuple([torch.cat((point.float(), torch.ones(1,1)), axis = 0) for point in keypoints])



