import torch
import math

device = 'cuda'


def keypoints_to_homogeneus_functional(keypoints):
    if keypoints[0].dim() == 1: keypoints = [point.reshape(2, 1) for point in keypoints]
    return tuple([torch.cat((point.float(), torch.ones(1, 1)), axis=0).to(device) for point in keypoints])


def keypoints_to_homogeneus_and_concatenate(keypoints):
    if keypoints[0].dim() == 1: keypoints = [point.reshape(2, 1) for point in keypoints]
    keypoints = tuple([torch.cat((point.float(), torch.ones(1, 1)), axis=0).to(device) for point in keypoints])
    compose_data = torch.cat((keypoints), 1)  # concatenate data into one multichannel pytoch tensor
    return compose_data


# converts the intermediate values ​​generated by the transformations to 0-1
def mask_change_to_01_functional(mask, img_range=255):
    half = math.ceil(img_range / 2)
    return mask // half


import numpy as np
import os
import cv2


def _apply_gaussian_noise(image, var = 20):
    gaussian_noise = np.zeros((image.shape[0], image.shape[1],1), dtype=np.uint8)
    cv2.randn(gaussian_noise, 50, 20)
    gaussian_noise = np.concatenate((gaussian_noise, gaussian_noise, gaussian_noise), axis=2)
    gaussian_noise = (gaussian_noise * var).astype(np.uint8)
    return cv2.add(image, gaussian_noise)

def _apply_salt_and_pepper_noise(image, amount=0.05, s_vs_p = 0.5 ):
    if not is_a_normalized_image(image):
        salt = 255
    else:
        salt = 1
    pepper = 0
    out = np.copy(image)
    # Salt mode
    num_salt = np.ceil(amount * image.size * s_vs_p)
    coords = [np.random.randint(0, i - 1, int(num_salt)) for i in image.shape]
    out[coords[0], coords[1], :] = salt
    # Pepper mode
    num_pepper = np.ceil(amount * image.size * (1. - s_vs_p))
    coords = [np.random.randint(0, i - 1, int(num_pepper))
              for i in image.shape]
    out[coords[0], coords[1], :] = pepper
    return out

def _apply_poisson_noise(image):
    noise = np.random.poisson(40, image.shape)
    return image + noise

def _apply_spekle_noise(image, intensity= 1):
    row, col, ch = image.shape
    streng_factor = 10 - intensity
    gauss = np.random.randn(row, col, ch)  / streng_factor
    gauss = gauss.reshape(row, col, ch)
    noisy = (image + image * gauss)
    return noisy

def apply_brightness_contrast(input_img, brightness = 0, contrast = 0):

    if brightness != 0:
        if brightness > 0:
            shadow = brightness
            highlight = 255
        else:
            shadow = 0
            highlight = 255 + brightness
        alpha_b = (highlight - shadow)/255
        gamma_b = shadow

        buf = cv2.addWeighted(input_img, alpha_b, input_img, 0, gamma_b)
    else:
        buf = input_img.copy()

    if contrast != 0:
        f = 131*(contrast + 127)/(127*(131-contrast))
        alpha_c = f
        gamma_c = 127*(1-f)

        buf = cv2.addWeighted(buf, alpha_c, buf, 0, gamma_c)

    return buf

def apply_gaussian_blur(img):
    return cv2.GaussianBlur(img, (5,5),cv2.BORDER_DEFAULT)

def _apply_blur(img):
    return cv2.blur(img, (5,5))

'''source; https://stackoverflow.com/questions/22937589/how-to-add-noise-gaussian-salt-and-pepper-etc-to-image-in-python-with-opencv'''
def noisy(noise_typ, image):
    if noise_typ == "gauss":
        row, col, ch = image.shape
        mean = 0
        var = 0.5
        sigma = var ** 0.5
        gauss = np.random.normal(mean, sigma, (row, col, ch))
        gauss = gauss.reshape(row, col, ch)
        noisy = image + gauss
        return noisy
    elif noise_typ == "poisson":
        vals = len(np.unique(image))
        vals = 2 ** np.ceil(np.log2(vals))
        noisy = np.random.poisson(image * vals) / float(vals)
        return noisy
    elif noise_typ == "speckle":
        row, col, ch = image.shape
        gauss = np.random.randn(row, col, ch)
        gauss = gauss.reshape(row, col, ch)
        noisy = image + image * gauss
        return noisy
    elif noise_typ == "s&p":
        row, col, ch = image.shape
        s_vs_p = 0.5
        amount = 0.04
        out = np.copy(image)
        # Salt mode
        num_salt = np.ceil(amount * image.size * s_vs_p)
        coords = [np.random.randint(0, i - 1, int(num_salt))
                  for i in image.shape]
        out[coords] = 1
        # Pepper mode
        num_pepper = np.ceil(amount * image.size * (1. - s_vs_p))
        coords = [np.random.randint(0, i - 1, int(num_pepper))
                  for i in image.shape]
        out[coords] = 0
        return out

def is_a_normalized_image(image):
    return image.min() >= 0 and image.max() <=1


def is_color_image(image):
    return len(image.shape) == 3 and image.shape[2] == 3