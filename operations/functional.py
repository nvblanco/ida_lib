import kornia
import torch
import abc
from abc import ABCMeta

from image_augmentation import visualization

data_types_2d = {"image", "mask", "heatmap"}
data_types_1d = {"keypoints"}

device = 'cuda'
one_torch = torch.ones(1).to(device)


def keypoints_to_homogeneus(keypoints):
    if keypoints[0].dim() == 1 : keypoints  = [point.reshape(2,1) for point in keypoints]
    return tuple([torch.cat((point.float(), torch.ones(1,1)), axis = 0).to(device) for point in keypoints])

#converts the intermediate values ​​generated by the transformations to 0-1
def mask_change_to_01(mask):
    for i in range(mask.shape[1]):
        for j in range(mask.shape[2]):
            if mask[0, i, j] < 0.5:
                mask[0, i, j] = 0
            else:
                mask[0, i, j] = 1



class transform(object):
    __metaclass__ = ABCMeta

    @abc.abstractmethod
    def __init__(self, data, visualize=False):
        result_data = {}
        if visualize:
            self.original = data
        if isinstance(data, dict):
            self.types_2d = {}
            compose_data = torch.tensor([])
            for type in data.keys():
                if type in data_types_2d:
                    compose_data = torch.cat((compose_data, data[type]),
                                             0)  # concatenate data into one multichannel pytoch tensor
                    self.types_2d[type] = data[type].shape[0]
                else:
                    self.points = data[type]
            self.data2d = compose_data.to(device)
            #self.types2d= types_2d
            if self.points is not None: self.data1d = keypoints_to_homogeneus(points)
            return result_data
        else:
            if data.dim() < 3:
                raise Exception("Single data must be al least 3 dims")
            else:
                self.data2d = data

    def postprocess_data(self):
        self.data2d = self.data2d .cpu()
        if self.types_2d is not None:
            data_output = {}
            data_split = torch.split(self.data2d,  list(self.types2d.values()), dim=0)
            for index, type in enumerate(self.types2d):
                data_output[type] = data_split[index]
            data_output['keypoints'] = [((dato.cpu())[:2, :]).reshape(2) for dato in self.data1d]
            if data_output.keys().__contains__('mask'): data_output['mask'] = mask_change_to_01(data_output['mask'])
        else:
            data_output = self.data2d
        if self.visualize:
            visualization.plot_image_tranformation(data_output, self.original)
        return data_output


class vflip(transform):
    def __init__(self, data, visualize=False):
        transform.__init__(self, data, visualize)

    def __call__(self, *args, **kwargs):
        self.data2d = kornia.vflip(self.data2d)
        if self.data1d is not None:
            heigth = self.data2d.shape[-2]
            for point in self.data1d:
                point[1] = heigth - point[1]
        return transform.postprocess_data()
