%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{IdaLib}
\date{Jun 24, 2020}
\release{0.0.1}
\author{Raquel Vilas}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.700\linewidth]{{icon}.png}\hspace*{\fill}}



IdaLib (Image Data Augmentation Library) is a library dedicated to the task of Image Data Augmentation in a fast, simple, efficient and flexible way
This library allows you to convert your input data into a larger and more diverse one to perform a better train of your Neural Network


\chapter{Features}
\label{\detokenize{index:features}}\begin{itemize}
\item {} 
Multiple fast augmentations based on Kornia an OpenCV libraries

\item {} 
Flexible

\item {} 
Complete tool, includes support for tasks associated with Pytorch\sphinxhyphen{}based neural networks

\item {} 
Supports multiple types of combined data (images, heat maps, segmentation maps, masks and keypoints)

\end{itemize}


\chapter{Instalation}
\label{\detokenize{index:instalation}}
You can use pip to install Ida\sphinxhyphen{}Lib

\sphinxcode{\sphinxupquote{pip install ida\sphinxhyphen{}lib}}

If you want to get the latest version of the code before it is released on PyPI you can install the library from GitHub:

\sphinxcode{\sphinxupquote{pip install \sphinxhyphen{}U git+https://github.com/raquelvilas18/ida\_lib}}


\chapter{Contents}
\label{\detokenize{index:contents}}

\section{Overview}
\label{\detokenize{overview:overview}}\label{\detokenize{overview::doc}}

\subsection{Functionalities}
\label{\detokenize{overview:functionalities}}
The functionalities on which IdaLib focuses are:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Offering a \sphinxstylestrong{wide variety of image transformations}.

\item {} 
Allow the \sphinxstylestrong{joint transformation}  of:
\begin{itemize}
\item {} 
image

\item {} 
heatmap

\item {} 
mask

\item {} 
segmaps

\item {} 
keypoints

\item {} 
any combination of them

\end{itemize}

\item {} 
Offer an \sphinxstylestrong{interactive visualization tool} that facilitates the debugging of programs.

\item {} 
Offer an \sphinxstylestrong{efficient operation composition pipeline} (parameterizable at probability and attribute level).

\item {} 
Offer a \sphinxstylestrong{Dataloader} object (as a generator) that integrates the pipeline and allows the supply of any neural network.

\item {} 
Offer a tool to perform \sphinxstylestrong{Image Data Augmentation directly to disk} in order to use the increased dataset directly in future situations

\end{enumerate}


\subsection{First steps}
\label{\detokenize{overview:first-steps}}
The central object of ida lib is its pipeline. To use it, just decide which PipelineOperations we want it to include. All other parameters are optional.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{example\PYGZus{}pipipeline} \PYG{o}{=} \PYG{n}{Pipeline}\PYG{p}{(}\PYG{n}{pipeline\PYGZus{}operations}\PYG{o}{=}\PYG{p}{(}
                     \PYG{n}{ScalePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,}
                     \PYG{n}{ShearPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{n}{shear}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                     \PYG{n}{TranslatePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{n}{translation}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                     \PYG{n}{HflipPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{n}{exchange\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
                     \PYG{n}{RandomRotatePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{n}{degrees\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}
                     \PYG{p}{)}
                     \PYG{p}{)}
\end{sphinxVerbatim}

The pipelineOperations can be divided into 2 groups:
\begin{itemize}
\item {} 
the \sphinxstylestrong{classic operations}, where you indicate exactly the parameters of the operation (for example \sphinxcode{\sphinxupquote{\textasciigrave{}RotatePipeline(degrees=20)\textasciigrave{}}} ). In {[}transformations{]}(\#operations) you can see what each one of them does

\item {} 
and the \sphinxstylestrong{Random pipelineOPerations}, where what you define is a range of possible parameters, and each time the operation is applied it will take a different value within this range (\sphinxcode{\sphinxupquote{RandomRotatePipeline(degrees\_range=(\sphinxhyphen{}20,30)}})

\end{itemize}

Once you have defined your pipeline, you can pass through it your batch data to be transformed.

\begin{sphinxadmonition}{warning}{Warning:}
Remember that the entry for the pipeline must be composed of Python dicts. To be treated correctly, each dict’s element must be associated with its type (images with ‘image1’, ‘image2’…; masks with ‘mask1’, ‘mask67’…):
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data1} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{img1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{keypoints}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{random\PYGZus{}coordinates}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mask}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{mask\PYGZus{}example1}\PYG{p}{\PYGZcb{}}
\PYG{n}{data2} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{img2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{keypoints2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{random\PYGZus{}coordinates2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mask}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{mask\PYGZus{}example2}\PYG{p}{\PYGZcb{}}
\PYG{n}{data3} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{img3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{keypoints3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{random\PYGZus{}coordinates3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mask}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{mask\PYGZus{}example3}\PYG{p}{\PYGZcb{}}

\PYG{n}{batch} \PYG{o}{=} \PYG{p}{[}\PYG{n}{data1}\PYG{p}{,} \PYG{n}{data2}\PYG{p}{,} \PYG{n}{data3}\PYG{p}{]}
\end{sphinxVerbatim}

Finally we run the pipeline as many times as necessary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{transformed\PYGZus{}batch} \PYG{o}{=} \PYG{n}{example\PYGZus{}pipipeline}\PYG{p}{(}\PYG{n}{batch}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Visualization tool}
\label{\detokenize{overview:visualization-tool}}
Ida Lib includes a tool to visualize the transformations to facilitate code debugging.
It is an interactive tool developed with the bokeh framework and allows the selection of the data to be displayed in the image.
\begin{itemize}
\item {} 
The color code is used to differentiate each element and identify it in all the images.

\item {} 
The dots are numbered in order to see their order

\item {} 
Allows to compare different transformations obtained by the pipeline

\item {} 
It also includes the targets in the visualization in order to have a complete view of the elements

\end{itemize}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=1.200\linewidth]{{visualization}.png}\hspace*{\fill}}

\begin{sphinxadmonition}{note}{Note:}
To test the visualization tool you can try this example:
\sphinxurl{https://github.com/raquelvilas18/ida\_lib/blob/master/examples/pipeline\_usage.py}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
For the visualization tool a bokeh server is deployed; therefore it is only possible to have one open execution.
It is important to close previous runs in order to open new windows
\end{sphinxadmonition}


\section{Transformations}
\label{\detokenize{transformations:transformations}}\label{\detokenize{transformations::doc}}
The transformations included in the library are:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstylestrong{hflip}: horizontal flipping the image

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{hflip}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxstylestrong{vflip}: vertical flipping the image

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{vflip}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxstylestrong{Affine}:carry out the transformation expressed in the operation matrix

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{affine}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxstylestrong{Rotate}:rotate the image by the indicated degrees counterclockwise

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{rotate}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxstylestrong{Shear}: linear map that displaces each point in fixed direction, by an amount proportional to its signed distance from the line that is parallel to that direction and goes through the origin

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{shear}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
\sphinxstylestrong{Scale}: scale the image by making it smaller or larger (crop equivalent)

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{scale}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
\sphinxstylestrong{Translate}: moves the image pixels to the positions indicated on each axis

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{translate}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{7}
\item {} 
\sphinxstylestrong{Change gamma}: adjust image’s gamma (luminance correction) .

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{gamma}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{8}
\item {} 
\sphinxstylestrong{Change contrast:}: change the image contrast.

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{contrast}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{9}
\item {} 
\sphinxstylestrong{Change brightness}: change the image brightness

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{brightness}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{10}
\item {} 
\sphinxstylestrong{Equalize histogram}: equalize the image histogram

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{equalization}.png}\hspace*{\fill}}

12. \sphinxstylestrong{Inject gaussian noise}: gaussian noise is a statistical noise having a probability density function (PDF) equal
to that of the normal distribution

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{gaussian_noise}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{12}
\item {} 
\sphinxstylestrong{Inject salt and pepper noise}: salt\sphinxhyphen{}and\sphinxhyphen{}pepper noise is a statistical noise compose of white (salt) and black (pepper) pixels

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{salt_pepper_noise}.png}\hspace*{\fill}}

14. \sphinxstylestrong{Inject spekle noise}: Speckle is a granular interference that inherently exists in and degrades the quality of the active radar,
synthetic aperture radar (SAR), medical ultrasound and optical coherence tomography images.
It is applied by adding the image multiplied by the noise matrix \sphinxhyphen{}\textgreater{} img + img * uniform\_noise

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{spekle_noise}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{14}
\item {} 
\sphinxstylestrong{Inject poisson noise}: It is applied by adding Poisson\sphinxhyphen{}distributed noise

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{poisson_noise}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{15}
\item {} 
\sphinxstylestrong{Blur}: blur image.

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{blur}.png}\hspace*{\fill}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{16}
\item {} 
\sphinxstylestrong{Gaussian blur}: blurring an image by a Gaussian function.

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{gaussian_blur}.png}\hspace*{\fill}}


\section{API}
\label{\detokenize{ida_lib:api}}\label{\detokenize{ida_lib::doc}}

\subsection{API packages}
\label{\detokenize{ida_lib:api-packages}}

\subsubsection{ida\_lib.core package}
\label{\detokenize{ida_lib.core:ida-lib-core-package}}\label{\detokenize{ida_lib.core::doc}}

\paragraph{Submodules}
\label{\detokenize{ida_lib.core:submodules}}

\paragraph{ida\_lib.core.pipeline module}
\label{\detokenize{ida_lib.core:module-ida_lib.core.pipeline}}\label{\detokenize{ida_lib.core:ida-lib-core-pipeline-module}}\index{module@\spxentry{module}!ida\_lib.core.pipeline@\spxentry{ida\_lib.core.pipeline}}\index{ida\_lib.core.pipeline@\spxentry{ida\_lib.core.pipeline}!module@\spxentry{module}}\index{Pipeline (class in ida\_lib.core.pipeline)@\spxentry{Pipeline}\spxextra{class in ida\_lib.core.pipeline}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline.Pipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline.}}\sphinxbfcode{\sphinxupquote{Pipeline}}}{\emph{\DUrole{n}{pipeline\_operations}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{resize}\DUrole{p}{:} \DUrole{n}{tuple} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{interpolation}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}bilinear\textquotesingle{}}}, \emph{\DUrole{n}{padding\_mode}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}zeros\textquotesingle{}}}, \emph{\DUrole{n}{output\_format}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}dict\textquotesingle{}}}, \emph{\DUrole{n}{output\_type}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}torch.dtype\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

The pipeline object represents the pipeline with data transformation operations (pictures, points). When executed,
on a batch of images,it applies the necessary transformations (being different on each image based on the
probabilities of each operation included).
\begin{quote}
\begin{description}
\item[{Considerations:}] \leavevmode
1)  The images must be of the same size, or the RESIZE operation must be included so that the
transformations can be applied correctly
2)  To run the pipeline, it accepts any type of input metadata named in the input dict. In particular it
gives special treatment
\begin{quote}
\begin{description}
\item[{to data named as:}] \leavevmode\begin{itemize}
\item {} 
Mask: it is affected by geometric transformations and its output is discrete to values of 0\sphinxhyphen{}1

\item {} 
Segmap: generalization of mask. Every value is discrete

\item {} 
Image:  affected by geometric and color transformations

\item {} 
Keypoints: geometric transformations are applied to them as coordinates.

\item {} 
Others: any other metadata will not be transformed (example: ‘tag’, ‘target’…)

\end{itemize}

\end{description}
\end{quote}

\end{description}

Example:
\begin{quote}
\begin{description}
\item[{pip = pipeline(resize = (25, 25),  pipeline\_operations=(}] \leavevmode
translate\_pipeline(probability=0.5, translation=(3, 0.05)),
vflip\_pipeline(probability=0.5),
hflip\_pipeline(probability=0.5),
contrast\_pipeline(probability=0.5, contrast\_factor=1),
random\_brightness\_pipeline(probability=0.2, brightness\_range=(1.5, 1.6)),
random\_scale\_pipeline(probability=1, scale\_range=(0.5, 1.5), center\_deviation=20),
random\_rotate\_pipeline(probability=0.2, degrees\_range=(\sphinxhyphen{}50, 50), center\_deviation=20))
\begin{quote}

))
\end{quote}

\end{description}
\end{quote}
\end{quote}
\index{get\_data\_types() (ida\_lib.core.pipeline.Pipeline method)@\spxentry{get\_data\_types()}\spxextra{ida\_lib.core.pipeline.Pipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline.Pipeline.get_data_types}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_data\_types}}}{}{{ $\rightarrow$ tuple}}
Returns the tuple of data types identified on the input data

\end{fulllineitems}


\end{fulllineitems}



\paragraph{ida\_lib.core.pipeline\_functional module}
\label{\detokenize{ida_lib.core:module-ida_lib.core.pipeline_functional}}\label{\detokenize{ida_lib.core:ida-lib-core-pipeline-functional-module}}\index{module@\spxentry{module}!ida\_lib.core.pipeline\_functional@\spxentry{ida\_lib.core.pipeline\_functional}}\index{ida\_lib.core.pipeline\_functional@\spxentry{ida\_lib.core.pipeline\_functional}!module@\spxentry{module}}\index{get\_compose\_matrix() (in module ida\_lib.core.pipeline\_functional)@\spxentry{get\_compose\_matrix()}\spxextra{in module ida\_lib.core.pipeline\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_functional.get_compose_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_functional.}}\sphinxbfcode{\sphinxupquote{get\_compose\_matrix}}}{\emph{\DUrole{n}{operations}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{data\_info}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}dict\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
Returns the transformation matrix composed by the multiplication in order of
the input operations (according to their probability)
If data\_info is not None, go through the operations by entering the necessary information about the images
(image center, shape..)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{operations}} \textendash{} list of pipeline operations

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_info}} \textendash{} dict with data info to configure operations parameters

\end{itemize}

\item[{Returns}] \leavevmode
torch tensor of the transform matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_compose\_function() (in module ida\_lib.core.pipeline\_functional)@\spxentry{get\_compose\_function()}\spxextra{in module ida\_lib.core.pipeline\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_functional.get_compose_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_functional.}}\sphinxbfcode{\sphinxupquote{get\_compose\_function}}}{\emph{\DUrole{n}{operations}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ numpy.ndarray}}
returns the LUT table with the correspondence of each possible value
according to the color operations to be implemented (according to their probability)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{operations}} \textendash{} list of pipeline operations

\item[{Returns}] \leavevmode
compose function

\end{description}\end{quote}

\end{fulllineitems}

\index{preprocess\_data() (in module ida\_lib.core.pipeline\_functional)@\spxentry{preprocess\_data()}\spxextra{in module ida\_lib.core.pipeline\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_functional.preprocess_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_functional.}}\sphinxbfcode{\sphinxupquote{preprocess\_data}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}list\DUrole{p}{, }dict\DUrole{p}{{]}}}}, \emph{\DUrole{n}{batch\_info}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}list\DUrole{p}{, }dict\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{interpolation}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{resize}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}tuple\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ list}}
Combines the 2d information in a tensor and the points in a homogeneous coordinate matrix     that allows applying the geometric operations in a single joint operation on the data     and another on the points.
\begin{itemize}
\item {} 
Loads the data as tensor in GPU to prepare them as input to a neural network

\item {} 
Analyze the data info required for the transformations (shape, bpp…)

\item {} 
Resize the 2d data and keypoints to the new shape

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{resize}} \textendash{} if it is wanted to resize the data, indicate the new size

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} list of elements to be transformed through the pipe

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{batch\_info}} \textendash{} dict with the required data info

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{interpolation}} \textendash{} desired interpolation mode to be applied

\end{itemize}

\item[{Returns}] \leavevmode
preprocessed and resized data, and dict with batch info

\end{description}\end{quote}

\end{fulllineitems}

\index{split\_operations\_by\_type() (in module ida\_lib.core.pipeline\_functional)@\spxentry{split\_operations\_by\_type()}\spxextra{in module ida\_lib.core.pipeline\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_functional.split_operations_by_type}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_functional.}}\sphinxbfcode{\sphinxupquote{split\_operations\_by\_type}}}{\emph{\DUrole{n}{operations}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ tuple}}
Split input operations into sub\sphinxhyphen{}lists of each transformation type
the normalization operation is placed last to apply correctly the other operations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{operations}} \textendash{} list of pipeline operations

\item[{Returns}] \leavevmode
tuple of lists of the operations separated into color, geometry and independent

\end{description}\end{quote}

\end{fulllineitems}

\index{postprocess\_data() (in module ida\_lib.core.pipeline\_functional)@\spxentry{postprocess\_data()}\spxextra{in module ida\_lib.core.pipeline\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_functional.postprocess_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_functional.}}\sphinxbfcode{\sphinxupquote{postprocess\_data}}}{\emph{\DUrole{n}{batch}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{batch\_info}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{data\_original}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}list\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{original\_type}\DUrole{p}{:} \DUrole{n}{torch.dtype} \DUrole{o}{=} \DUrole{default_value}{torch.uint8}}, \emph{\DUrole{n}{output\_format}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}dict\textquotesingle{}}}}{{ $\rightarrow$ list}}
Restores the data to the original form;
separating the matrix into the different 2d input data and point coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{batch}} \textendash{} list of elements to be transformed through the pipe

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{batch\_info}} \textendash{} dict with necessary information about the batch data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_original}} \textendash{} original batch before transforms

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} whether to run the visualization tool or not

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{original\_type}} \textendash{} torch original type of the input data to do the conversion of the output data to this type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_format}} \textendash{} whether to format the output element as a dict or as a tuple

\end{itemize}

\item[{Returns}] \leavevmode
processed data

\end{description}\end{quote}

\end{fulllineitems}

\index{switch\_point\_positions() (in module ida\_lib.core.pipeline\_functional)@\spxentry{switch\_point\_positions()}\spxextra{in module ida\_lib.core.pipeline\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_functional.switch_point_positions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_functional.}}\sphinxbfcode{\sphinxupquote{switch\_point\_positions}}}{\emph{\DUrole{n}{point\_matrix}}, \emph{\DUrole{n}{input\_list}}}{}
\end{fulllineitems}



\paragraph{ida\_lib.core.pipeline\_geometric\_ops module}
\label{\detokenize{ida_lib.core:module-ida_lib.core.pipeline_geometric_ops}}\label{\detokenize{ida_lib.core:ida-lib-core-pipeline-geometric-ops-module}}\index{module@\spxentry{module}!ida\_lib.core.pipeline\_geometric\_ops@\spxentry{ida\_lib.core.pipeline\_geometric\_ops}}\index{ida\_lib.core.pipeline\_geometric\_ops@\spxentry{ida\_lib.core.pipeline\_geometric\_ops}!module@\spxentry{module}}\index{HflipPipeline (class in ida\_lib.core.pipeline\_geometric\_ops)@\spxentry{HflipPipeline}\spxextra{class in ida\_lib.core.pipeline\_geometric\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.HflipPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_geometric\_ops.}}\sphinxbfcode{\sphinxupquote{HflipPipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{exchange\_points}\DUrole{p}{:} \DUrole{n}{tuple} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Horizontally flip the input image\sphinxhyphen{}mask\sphinxhyphen{}keypoints and 2d data
\index{config\_parameters() (ida\_lib.core.pipeline\_geometric\_ops.HflipPipeline method)@\spxentry{config\_parameters()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.HflipPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.HflipPipeline.config_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{config\_parameters}}}{\emph{\DUrole{n}{data\_info}\DUrole{p}{:} \DUrole{n}{dict}}}{}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_geometric\_ops.HflipPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.HflipPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.HflipPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{need\_data\_info() (ida\_lib.core.pipeline\_geometric\_ops.HflipPipeline method)@\spxentry{need\_data\_info()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.HflipPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.HflipPipeline.need_data_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{need\_data\_info}}}{}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{switch\_points() (ida\_lib.core.pipeline\_geometric\_ops.HflipPipeline method)@\spxentry{switch\_points()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.HflipPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.HflipPipeline.switch_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{switch\_points}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{VflipPipeline (class in ida\_lib.core.pipeline\_geometric\_ops)@\spxentry{VflipPipeline}\spxextra{class in ida\_lib.core.pipeline\_geometric\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.VflipPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_geometric\_ops.}}\sphinxbfcode{\sphinxupquote{VflipPipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{exchange\_points}\DUrole{p}{:} \DUrole{n}{tuple} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Vertically flip the input image\sphinxhyphen{}mask\sphinxhyphen{}keypoints and 2d data
\index{config\_parameters() (ida\_lib.core.pipeline\_geometric\_ops.VflipPipeline method)@\spxentry{config\_parameters()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.VflipPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.VflipPipeline.config_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{config\_parameters}}}{\emph{\DUrole{n}{data\_info}\DUrole{p}{:} \DUrole{n}{dict}}}{}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_geometric\_ops.VflipPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.VflipPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.VflipPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{need\_data\_info() (ida\_lib.core.pipeline\_geometric\_ops.VflipPipeline method)@\spxentry{need\_data\_info()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.VflipPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.VflipPipeline.need_data_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{need\_data\_info}}}{}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{switch\_points() (ida\_lib.core.pipeline\_geometric\_ops.VflipPipeline method)@\spxentry{switch\_points()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.VflipPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.VflipPipeline.switch_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{switch\_points}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{RotatePipeline (class in ida\_lib.core.pipeline\_geometric\_ops)@\spxentry{RotatePipeline}\spxextra{class in ida\_lib.core.pipeline\_geometric\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RotatePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_geometric\_ops.}}\sphinxbfcode{\sphinxupquote{RotatePipeline}}}{\emph{\DUrole{n}{degrees}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Rotate the input image\sphinxhyphen{}mask\sphinxhyphen{}keypoints and 2d data by the input degrees
\index{config\_parameters() (ida\_lib.core.pipeline\_geometric\_ops.RotatePipeline method)@\spxentry{config\_parameters()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RotatePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RotatePipeline.config_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{config\_parameters}}}{\emph{\DUrole{n}{data\_info}\DUrole{p}{:} \DUrole{n}{dict}}}{}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_geometric\_ops.RotatePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RotatePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RotatePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{need\_data\_info() (ida\_lib.core.pipeline\_geometric\_ops.RotatePipeline method)@\spxentry{need\_data\_info()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RotatePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RotatePipeline.need_data_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{need\_data\_info}}}{}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{switch\_points() (ida\_lib.core.pipeline\_geometric\_ops.RotatePipeline static method)@\spxentry{switch\_points()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RotatePipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RotatePipeline.switch_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{switch\_points}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{ShearPipeline (class in ida\_lib.core.pipeline\_geometric\_ops)@\spxentry{ShearPipeline}\spxextra{class in ida\_lib.core.pipeline\_geometric\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.ShearPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_geometric\_ops.}}\sphinxbfcode{\sphinxupquote{ShearPipeline}}}{\emph{\DUrole{n}{shear}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Shear the input image\sphinxhyphen{}mask\sphinxhyphen{}keypoints and 2d data by the input shear factor
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_geometric\_ops.ShearPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.ShearPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.ShearPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{need\_data\_info() (ida\_lib.core.pipeline\_geometric\_ops.ShearPipeline static method)@\spxentry{need\_data\_info()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.ShearPipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.ShearPipeline.need_data_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{need\_data\_info}}}{}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{switch\_points() (ida\_lib.core.pipeline\_geometric\_ops.ShearPipeline static method)@\spxentry{switch\_points()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.ShearPipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.ShearPipeline.switch_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{switch\_points}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{ScalePipeline (class in ida\_lib.core.pipeline\_geometric\_ops)@\spxentry{ScalePipeline}\spxextra{class in ida\_lib.core.pipeline\_geometric\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.ScalePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_geometric\_ops.}}\sphinxbfcode{\sphinxupquote{ScalePipeline}}}{\emph{\DUrole{n}{scale\_factor}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}float\DUrole{p}{, }tuple\DUrole{p}{{]}}}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Scale the input image\sphinxhyphen{}mask\sphinxhyphen{}keypoints and 2d data by the input scaling value
\index{config\_parameters() (ida\_lib.core.pipeline\_geometric\_ops.ScalePipeline method)@\spxentry{config\_parameters()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.ScalePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.ScalePipeline.config_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{config\_parameters}}}{\emph{\DUrole{n}{data\_info}\DUrole{p}{:} \DUrole{n}{dict}}}{}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_geometric\_ops.ScalePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.ScalePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.ScalePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{need\_data\_info() (ida\_lib.core.pipeline\_geometric\_ops.ScalePipeline method)@\spxentry{need\_data\_info()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.ScalePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.ScalePipeline.need_data_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{need\_data\_info}}}{}{}
\end{fulllineitems}

\index{switch\_points() (ida\_lib.core.pipeline\_geometric\_ops.ScalePipeline static method)@\spxentry{switch\_points()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.ScalePipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.ScalePipeline.switch_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{switch\_points}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{TranslatePipeline (class in ida\_lib.core.pipeline\_geometric\_ops)@\spxentry{TranslatePipeline}\spxextra{class in ida\_lib.core.pipeline\_geometric\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.TranslatePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_geometric\_ops.}}\sphinxbfcode{\sphinxupquote{TranslatePipeline}}}{\emph{\DUrole{n}{translation}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Translate the input image\sphinxhyphen{}mask\sphinxhyphen{}keypoints and 2d data by the input translation
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_geometric\_ops.TranslatePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.TranslatePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.TranslatePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{need\_data\_info() (ida\_lib.core.pipeline\_geometric\_ops.TranslatePipeline static method)@\spxentry{need\_data\_info()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.TranslatePipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.TranslatePipeline.need_data_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{need\_data\_info}}}{}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{switch\_points() (ida\_lib.core.pipeline\_geometric\_ops.TranslatePipeline static method)@\spxentry{switch\_points()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.TranslatePipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.TranslatePipeline.switch_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{switch\_points}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{RandomScalePipeline (class in ida\_lib.core.pipeline\_geometric\_ops)@\spxentry{RandomScalePipeline}\spxextra{class in ida\_lib.core.pipeline\_geometric\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomScalePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_geometric\_ops.}}\sphinxbfcode{\sphinxupquote{RandomScalePipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{scale\_range}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{keep\_aspect}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{center\_deviation}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Scale the input image\sphinxhyphen{}mask\sphinxhyphen{}keypoints and 2d data by a random scaling value calculated within the input range
\index{config\_parameters() (ida\_lib.core.pipeline\_geometric\_ops.RandomScalePipeline method)@\spxentry{config\_parameters()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomScalePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomScalePipeline.config_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{config\_parameters}}}{\emph{\DUrole{n}{data\_info}\DUrole{p}{:} \DUrole{n}{dict}}}{}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_geometric\_ops.RandomScalePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomScalePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomScalePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{need\_data\_info() (ida\_lib.core.pipeline\_geometric\_ops.RandomScalePipeline method)@\spxentry{need\_data\_info()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomScalePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomScalePipeline.need_data_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{need\_data\_info}}}{}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{switch\_points() (ida\_lib.core.pipeline\_geometric\_ops.RandomScalePipeline static method)@\spxentry{switch\_points()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomScalePipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomScalePipeline.switch_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{switch\_points}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{RandomRotatePipeline (class in ida\_lib.core.pipeline\_geometric\_ops)@\spxentry{RandomRotatePipeline}\spxextra{class in ida\_lib.core.pipeline\_geometric\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomRotatePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_geometric\_ops.}}\sphinxbfcode{\sphinxupquote{RandomRotatePipeline}}}{\emph{\DUrole{n}{degrees\_range}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{center\_deviation}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Rotate the input image\sphinxhyphen{}mask\sphinxhyphen{}keypoints and 2d data by a random scaling value calculated within the input range
\index{config\_parameters() (ida\_lib.core.pipeline\_geometric\_ops.RandomRotatePipeline method)@\spxentry{config\_parameters()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomRotatePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomRotatePipeline.config_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{config\_parameters}}}{\emph{\DUrole{n}{data\_info}\DUrole{p}{:} \DUrole{n}{dict}}}{}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_geometric\_ops.RandomRotatePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomRotatePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomRotatePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{need\_data\_info() (ida\_lib.core.pipeline\_geometric\_ops.RandomRotatePipeline method)@\spxentry{need\_data\_info()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomRotatePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomRotatePipeline.need_data_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{need\_data\_info}}}{}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{switch\_points() (ida\_lib.core.pipeline\_geometric\_ops.RandomRotatePipeline static method)@\spxentry{switch\_points()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomRotatePipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomRotatePipeline.switch_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{switch\_points}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{RandomShearPipeline (class in ida\_lib.core.pipeline\_geometric\_ops)@\spxentry{RandomShearPipeline}\spxextra{class in ida\_lib.core.pipeline\_geometric\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomShearPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_geometric\_ops.}}\sphinxbfcode{\sphinxupquote{RandomShearPipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{shear\_range}\DUrole{p}{:} \DUrole{n}{tuple}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Shear the input image\sphinxhyphen{}mask\sphinxhyphen{}keypoints and 2d data by a random shear value calculated within the input range
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_geometric\_ops.RandomShearPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomShearPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomShearPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{need\_data\_info() (ida\_lib.core.pipeline\_geometric\_ops.RandomShearPipeline static method)@\spxentry{need\_data\_info()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomShearPipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomShearPipeline.need_data_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{need\_data\_info}}}{}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{switch\_points() (ida\_lib.core.pipeline\_geometric\_ops.RandomShearPipeline static method)@\spxentry{switch\_points()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomShearPipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomShearPipeline.switch_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{switch\_points}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{RandomTranslatePipeline (class in ida\_lib.core.pipeline\_geometric\_ops)@\spxentry{RandomTranslatePipeline}\spxextra{class in ida\_lib.core.pipeline\_geometric\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomTranslatePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_geometric\_ops.}}\sphinxbfcode{\sphinxupquote{RandomTranslatePipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{translation\_range}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{same\_translation\_on\_axis}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Translate the input image\sphinxhyphen{}mask\sphinxhyphen{}keypoints and 2d data by a random translation value calculated within
the input range
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_geometric\_ops.RandomTranslatePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomTranslatePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomTranslatePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{need\_data\_info() (ida\_lib.core.pipeline\_geometric\_ops.RandomTranslatePipeline static method)@\spxentry{need\_data\_info()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomTranslatePipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomTranslatePipeline.need_data_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{need\_data\_info}}}{}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{switch\_points() (ida\_lib.core.pipeline\_geometric\_ops.RandomTranslatePipeline static method)@\spxentry{switch\_points()}\spxextra{ida\_lib.core.pipeline\_geometric\_ops.RandomTranslatePipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_geometric_ops.RandomTranslatePipeline.switch_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{switch\_points}}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\paragraph{ida\_lib.core.pipeline\_local\_ops module}
\label{\detokenize{ida_lib.core:module-ida_lib.core.pipeline_local_ops}}\label{\detokenize{ida_lib.core:ida-lib-core-pipeline-local-ops-module}}\index{module@\spxentry{module}!ida\_lib.core.pipeline\_local\_ops@\spxentry{ida\_lib.core.pipeline\_local\_ops}}\index{ida\_lib.core.pipeline\_local\_ops@\spxentry{ida\_lib.core.pipeline\_local\_ops}!module@\spxentry{module}}\index{BlurPipeline (class in ida\_lib.core.pipeline\_local\_ops)@\spxentry{BlurPipeline}\spxextra{class in ida\_lib.core.pipeline\_local\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.BlurPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_local\_ops.}}\sphinxbfcode{\sphinxupquote{BlurPipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{blur\_size}\DUrole{p}{:} \DUrole{n}{tuple} \DUrole{o}{=} \DUrole{default_value}{5, 5}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Blur input image ( non\sphinxhyphen{}weighted blur)
\index{apply\_to\_image\_if\_probability() (ida\_lib.core.pipeline\_local\_ops.BlurPipeline method)@\spxentry{apply\_to\_image\_if\_probability()}\spxextra{ida\_lib.core.pipeline\_local\_ops.BlurPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.BlurPipeline.apply_to_image_if_probability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{apply\_to\_image\_if\_probability}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_local\_ops.BlurPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_local\_ops.BlurPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.BlurPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{GaussianBlurPipeline (class in ida\_lib.core.pipeline\_local\_ops)@\spxentry{GaussianBlurPipeline}\spxextra{class in ida\_lib.core.pipeline\_local\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.GaussianBlurPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_local\_ops.}}\sphinxbfcode{\sphinxupquote{GaussianBlurPipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{blur\_size}\DUrole{p}{:} \DUrole{n}{tuple} \DUrole{o}{=} \DUrole{default_value}{5, 5}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Blur input image by a Gaussian function
\index{apply\_to\_image\_if\_probability() (ida\_lib.core.pipeline\_local\_ops.GaussianBlurPipeline method)@\spxentry{apply\_to\_image\_if\_probability()}\spxextra{ida\_lib.core.pipeline\_local\_ops.GaussianBlurPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.GaussianBlurPipeline.apply_to_image_if_probability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{apply\_to\_image\_if\_probability}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_local\_ops.GaussianBlurPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_local\_ops.GaussianBlurPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.GaussianBlurPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{GaussianNoisePipeline (class in ida\_lib.core.pipeline\_local\_ops)@\spxentry{GaussianNoisePipeline}\spxextra{class in ida\_lib.core.pipeline\_local\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.GaussianNoisePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_local\_ops.}}\sphinxbfcode{\sphinxupquote{GaussianNoisePipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{var}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{0.5}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Add gaussian noise to the input image
(gaussian noise is a statistical noise having a probability density function (PDF) equal to that of the normal      distribution)
\index{apply\_to\_image\_if\_probability() (ida\_lib.core.pipeline\_local\_ops.GaussianNoisePipeline method)@\spxentry{apply\_to\_image\_if\_probability()}\spxextra{ida\_lib.core.pipeline\_local\_ops.GaussianNoisePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.GaussianNoisePipeline.apply_to_image_if_probability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{apply\_to\_image\_if\_probability}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_local\_ops.GaussianNoisePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_local\_ops.GaussianNoisePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.GaussianNoisePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{PoissonNoisePipeline (class in ida\_lib.core.pipeline\_local\_ops)@\spxentry{PoissonNoisePipeline}\spxextra{class in ida\_lib.core.pipeline\_local\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.PoissonNoisePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_local\_ops.}}\sphinxbfcode{\sphinxupquote{PoissonNoisePipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Add poison noise to the input image
(Speckle is a granular interference that inherently exists in and degrades the quality of the active radar,
synthetic aperture radar (SAR), medical ultrasound and optical coherence tomography images.
It is applied by adding Poisson\sphinxhyphen{}distributed noise)
\index{apply\_to\_image\_if\_probability() (ida\_lib.core.pipeline\_local\_ops.PoissonNoisePipeline method)@\spxentry{apply\_to\_image\_if\_probability()}\spxextra{ida\_lib.core.pipeline\_local\_ops.PoissonNoisePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.PoissonNoisePipeline.apply_to_image_if_probability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{apply\_to\_image\_if\_probability}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_local\_ops.PoissonNoisePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_local\_ops.PoissonNoisePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.PoissonNoisePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{SaltAndPepperNoisePipeline (class in ida\_lib.core.pipeline\_local\_ops)@\spxentry{SaltAndPepperNoisePipeline}\spxextra{class in ida\_lib.core.pipeline\_local\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.SaltAndPepperNoisePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_local\_ops.}}\sphinxbfcode{\sphinxupquote{SaltAndPepperNoisePipeline}}}{\emph{\DUrole{n}{probability}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{amount}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}float\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{0.01}}, \emph{\DUrole{n}{s\_vs\_p}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}float\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{0.5}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Add salt and pepper noise to the input image
(salt\sphinxhyphen{}and\sphinxhyphen{}pepper noise is a statistical noise compose of white (salt) and black (pepper) pixels)
\index{apply\_to\_image\_if\_probability() (ida\_lib.core.pipeline\_local\_ops.SaltAndPepperNoisePipeline method)@\spxentry{apply\_to\_image\_if\_probability()}\spxextra{ida\_lib.core.pipeline\_local\_ops.SaltAndPepperNoisePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.SaltAndPepperNoisePipeline.apply_to_image_if_probability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{apply\_to\_image\_if\_probability}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_local\_ops.SaltAndPepperNoisePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_local\_ops.SaltAndPepperNoisePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.SaltAndPepperNoisePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{SpekleNoisePipeline (class in ida\_lib.core.pipeline\_local\_ops)@\spxentry{SpekleNoisePipeline}\spxextra{class in ida\_lib.core.pipeline\_local\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.SpekleNoisePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_local\_ops.}}\sphinxbfcode{\sphinxupquote{SpekleNoisePipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{mean}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}float\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{0}}, \emph{\DUrole{n}{var}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}float\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{0.01}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Add spekle noise to the input image
(Speckle is a granular interference that inherently exists in and degrades the quality of the active radar,
synthetic aperture radar (SAR), medical ultrasound and optical coherence tomography images.
It is applied by adding the image multiplied by the noise matrix \sphinxhyphen{}\textgreater{} img + img * uniform\_noise)
\index{apply\_to\_image\_if\_probability() (ida\_lib.core.pipeline\_local\_ops.SpekleNoisePipeline method)@\spxentry{apply\_to\_image\_if\_probability()}\spxextra{ida\_lib.core.pipeline\_local\_ops.SpekleNoisePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.SpekleNoisePipeline.apply_to_image_if_probability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{apply\_to\_image\_if\_probability}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_local\_ops.SpekleNoisePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_local\_ops.SpekleNoisePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_local_ops.SpekleNoisePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\paragraph{ida\_lib.core.pipeline\_operations module}
\label{\detokenize{ida_lib.core:module-ida_lib.core.pipeline_operations}}\label{\detokenize{ida_lib.core:ida-lib-core-pipeline-operations-module}}\index{module@\spxentry{module}!ida\_lib.core.pipeline\_operations@\spxentry{ida\_lib.core.pipeline\_operations}}\index{ida\_lib.core.pipeline\_operations@\spxentry{ida\_lib.core.pipeline\_operations}!module@\spxentry{module}}\index{PipelineOperation (class in ida\_lib.core.pipeline\_operations)@\spxentry{PipelineOperation}\spxextra{class in ida\_lib.core.pipeline\_operations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.}}\sphinxbfcode{\sphinxupquote{PipelineOperation}}}{\emph{\DUrole{n}{op\_type}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

Abstract class of pipeline operations
\index{apply\_according\_to\_probability() (ida\_lib.core.pipeline\_operations.PipelineOperation method)@\spxentry{apply\_according\_to\_probability()}\spxextra{ida\_lib.core.pipeline\_operations.PipelineOperation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation.apply_according_to_probability}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{apply\_according\_to\_probability}}}{}{{ $\rightarrow$ bool}}
\end{fulllineitems}

\index{get\_op\_matrix() (ida\_lib.core.pipeline\_operations.PipelineOperation method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_operations.PipelineOperation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{get\_op\_type() (ida\_lib.core.pipeline\_operations.PipelineOperation method)@\spxentry{get\_op\_type()}\spxextra{ida\_lib.core.pipeline\_operations.PipelineOperation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation.get_op_type}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_type}}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\paragraph{ida\_lib.core.pipeline\_pixel\_ops module}
\label{\detokenize{ida_lib.core:module-ida_lib.core.pipeline_pixel_ops}}\label{\detokenize{ida_lib.core:ida-lib-core-pipeline-pixel-ops-module}}\index{module@\spxentry{module}!ida\_lib.core.pipeline\_pixel\_ops@\spxentry{ida\_lib.core.pipeline\_pixel\_ops}}\index{ida\_lib.core.pipeline\_pixel\_ops@\spxentry{ida\_lib.core.pipeline\_pixel\_ops}!module@\spxentry{module}}\index{ContrastPipeline (class in ida\_lib.core.pipeline\_pixel\_ops)@\spxentry{ContrastPipeline}\spxextra{class in ida\_lib.core.pipeline\_pixel\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.ContrastPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_pixel\_ops.}}\sphinxbfcode{\sphinxupquote{ContrastPipeline}}}{\emph{\DUrole{n}{contrast\_factor}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Change the contrast of the input image.
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_pixel\_ops.ContrastPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.ContrastPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.ContrastPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{transform\_function() (ida\_lib.core.pipeline\_pixel\_ops.ContrastPipeline method)@\spxentry{transform\_function()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.ContrastPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.ContrastPipeline.transform_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform\_function}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ float}}
\end{fulllineitems}


\end{fulllineitems}

\index{RandomContrastPipeline (class in ida\_lib.core.pipeline\_pixel\_ops)@\spxentry{RandomContrastPipeline}\spxextra{class in ida\_lib.core.pipeline\_pixel\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.RandomContrastPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_pixel\_ops.}}\sphinxbfcode{\sphinxupquote{RandomContrastPipeline}}}{\emph{\DUrole{n}{contrast\_range}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Change the contrast of the input image with a random contrast factor calculated within the input range
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_pixel\_ops.RandomContrastPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.RandomContrastPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.RandomContrastPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{transform\_function() (ida\_lib.core.pipeline\_pixel\_ops.RandomContrastPipeline method)@\spxentry{transform\_function()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.RandomContrastPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.RandomContrastPipeline.transform_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform\_function}}}{\emph{\DUrole{n}{x}}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{BrightnessPipeline (class in ida\_lib.core.pipeline\_pixel\_ops)@\spxentry{BrightnessPipeline}\spxextra{class in ida\_lib.core.pipeline\_pixel\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.BrightnessPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_pixel\_ops.}}\sphinxbfcode{\sphinxupquote{BrightnessPipeline}}}{\emph{\DUrole{n}{brightness\_factor}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Change brightness of the input image
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_pixel\_ops.BrightnessPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.BrightnessPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.BrightnessPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{get\_op\_type() (ida\_lib.core.pipeline\_pixel\_ops.BrightnessPipeline method)@\spxentry{get\_op\_type()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.BrightnessPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.BrightnessPipeline.get_op_type}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_type}}}{}{}
\end{fulllineitems}

\index{transform\_function() (ida\_lib.core.pipeline\_pixel\_ops.BrightnessPipeline method)@\spxentry{transform\_function()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.BrightnessPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.BrightnessPipeline.transform_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform\_function}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ float}}
\end{fulllineitems}


\end{fulllineitems}

\index{RandomBrightnessPipeline (class in ida\_lib.core.pipeline\_pixel\_ops)@\spxentry{RandomBrightnessPipeline}\spxextra{class in ida\_lib.core.pipeline\_pixel\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.RandomBrightnessPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_pixel\_ops.}}\sphinxbfcode{\sphinxupquote{RandomBrightnessPipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{brightness\_range}\DUrole{p}{:} \DUrole{n}{tuple}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Change brightness of the input image to random amount calculated within the input range
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_pixel\_ops.RandomBrightnessPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.RandomBrightnessPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.RandomBrightnessPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{get\_op\_type() (ida\_lib.core.pipeline\_pixel\_ops.RandomBrightnessPipeline method)@\spxentry{get\_op\_type()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.RandomBrightnessPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.RandomBrightnessPipeline.get_op_type}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_type}}}{}{}
\end{fulllineitems}

\index{transform\_function() (ida\_lib.core.pipeline\_pixel\_ops.RandomBrightnessPipeline method)@\spxentry{transform\_function()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.RandomBrightnessPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.RandomBrightnessPipeline.transform_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform\_function}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ float}}
\end{fulllineitems}


\end{fulllineitems}

\index{GammaPipeline (class in ida\_lib.core.pipeline\_pixel\_ops)@\spxentry{GammaPipeline}\spxextra{class in ida\_lib.core.pipeline\_pixel\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.GammaPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_pixel\_ops.}}\sphinxbfcode{\sphinxupquote{GammaPipeline}}}{\emph{\DUrole{n}{gamma\_factor}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Change the luminance of the input image
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_pixel\_ops.GammaPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.GammaPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.GammaPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{transform\_function() (ida\_lib.core.pipeline\_pixel\_ops.GammaPipeline method)@\spxentry{transform\_function()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.GammaPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.GammaPipeline.transform_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform\_function}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ float}}
\end{fulllineitems}


\end{fulllineitems}

\index{RandomGammaPipeline (class in ida\_lib.core.pipeline\_pixel\_ops)@\spxentry{RandomGammaPipeline}\spxextra{class in ida\_lib.core.pipeline\_pixel\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.RandomGammaPipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_pixel\_ops.}}\sphinxbfcode{\sphinxupquote{RandomGammaPipeline}}}{\emph{\DUrole{n}{gamma\_range}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Change the luminance of the input image by a random gamma factor calculated within the input range
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_pixel\_ops.RandomGammaPipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.RandomGammaPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.RandomGammaPipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{transform\_function() (ida\_lib.core.pipeline\_pixel\_ops.RandomGammaPipeline method)@\spxentry{transform\_function()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.RandomGammaPipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.RandomGammaPipeline.transform_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform\_function}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ float}}
\end{fulllineitems}


\end{fulllineitems}

\index{NormalizePipeline (class in ida\_lib.core.pipeline\_pixel\_ops)@\spxentry{NormalizePipeline}\spxextra{class in ida\_lib.core.pipeline\_pixel\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.NormalizePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_pixel\_ops.}}\sphinxbfcode{\sphinxupquote{NormalizePipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{old\_range}\DUrole{p}{:} \DUrole{n}{tuple} \DUrole{o}{=} \DUrole{default_value}{0, 255}}, \emph{\DUrole{n}{new\_range}\DUrole{p}{:} \DUrole{n}{tuple} \DUrole{o}{=} \DUrole{default_value}{0, 1}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Change the pixels value to a normalize range
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_pixel\_ops.NormalizePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.NormalizePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.NormalizePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{transform\_function() (ida\_lib.core.pipeline\_pixel\_ops.NormalizePipeline static method)@\spxentry{transform\_function()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.NormalizePipeline static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.NormalizePipeline.transform_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{transform\_function}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ float}}
\end{fulllineitems}


\end{fulllineitems}

\index{DenormalizePipeline (class in ida\_lib.core.pipeline\_pixel\_ops)@\spxentry{DenormalizePipeline}\spxextra{class in ida\_lib.core.pipeline\_pixel\_ops}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.DenormalizePipeline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_pixel\_ops.}}\sphinxbfcode{\sphinxupquote{DenormalizePipeline}}}{\emph{\DUrole{n}{probability}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{old\_range}\DUrole{p}{:} \DUrole{n}{tuple} \DUrole{o}{=} \DUrole{default_value}{0, 1}}, \emph{\DUrole{n}{new\_range}\DUrole{p}{:} \DUrole{n}{tuple} \DUrole{o}{=} \DUrole{default_value}{0, 255}}}{}
Bases: {\hyperref[\detokenize{ida_lib.core:ida_lib.core.pipeline_operations.PipelineOperation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ida\_lib.core.pipeline\_operations.PipelineOperation}}}}}

Denormalize pixel value
\index{get\_op\_matrix() (ida\_lib.core.pipeline\_pixel\_ops.DenormalizePipeline method)@\spxentry{get\_op\_matrix()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.DenormalizePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.DenormalizePipeline.get_op_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_op\_matrix}}}{}{}
\end{fulllineitems}

\index{transform\_function() (ida\_lib.core.pipeline\_pixel\_ops.DenormalizePipeline method)@\spxentry{transform\_function()}\spxextra{ida\_lib.core.pipeline\_pixel\_ops.DenormalizePipeline method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.core:ida_lib.core.pipeline_pixel_ops.DenormalizePipeline.transform_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform\_function}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ float}}
\end{fulllineitems}


\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{ida_lib.core:module-ida_lib.core}}\label{\detokenize{ida_lib.core:module-contents}}\index{module@\spxentry{module}!ida\_lib.core@\spxentry{ida\_lib.core}}\index{ida\_lib.core@\spxentry{ida\_lib.core}!module@\spxentry{module}}

\subsubsection{ida\_lib.image\_augmentation package}
\label{\detokenize{ida_lib.image_augmentation:ida-lib-image-augmentation-package}}\label{\detokenize{ida_lib.image_augmentation::doc}}

\paragraph{Submodules}
\label{\detokenize{ida_lib.image_augmentation:submodules}}

\paragraph{ida\_lib.image\_augmentation.augment\_to\_disk module}
\label{\detokenize{ida_lib.image_augmentation:module-ida_lib.image_augmentation.augment_to_disk}}\label{\detokenize{ida_lib.image_augmentation:ida-lib-image-augmentation-augment-to-disk-module}}\index{module@\spxentry{module}!ida\_lib.image\_augmentation.augment\_to\_disk@\spxentry{ida\_lib.image\_augmentation.augment\_to\_disk}}\index{ida\_lib.image\_augmentation.augment\_to\_disk@\spxentry{ida\_lib.image\_augmentation.augment\_to\_disk}!module@\spxentry{module}}\index{AugmentToDisk (class in ida\_lib.image\_augmentation.augment\_to\_disk)@\spxentry{AugmentToDisk}\spxextra{class in ida\_lib.image\_augmentation.augment\_to\_disk}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.image_augmentation:ida_lib.image_augmentation.augment_to_disk.AugmentToDisk}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.image\_augmentation.augment\_to\_disk.}}\sphinxbfcode{\sphinxupquote{AugmentToDisk}}}{\emph{\DUrole{n}{dataset}\DUrole{p}{:} \DUrole{n}{torch.utils.data.dataset.Dataset}}, \emph{\DUrole{n}{samples\_per\_item}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{2}}, \emph{\DUrole{n}{total\_output\_samples}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{operations}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}list\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{interpolation}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}bilinear\textquotesingle{}}}, \emph{\DUrole{n}{padding\_mode}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}zeros\textquotesingle{}}}, \emph{\DUrole{n}{resize}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}tuple\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{output\_extension}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}.jpg\textquotesingle{}}}, \emph{\DUrole{n}{output\_csv\_path}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}annotations.csv\textquotesingle{}}}, \emph{\DUrole{n}{output\_path}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}./augmented\textquotesingle{}}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

The AugmentToDisk object allows to perform Data Image Augmentation directly to disk. That is, to save the images
generated to disk to be used in future processes.
\index{final\_save() (ida\_lib.image\_augmentation.augment\_to\_disk.AugmentToDisk method)@\spxentry{final\_save()}\spxextra{ida\_lib.image\_augmentation.augment\_to\_disk.AugmentToDisk method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.image_augmentation:ida_lib.image_augmentation.augment_to_disk.AugmentToDisk.final_save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{final\_save}}}{}{}~\begin{quote}

\sphinxstylestrong{This method can be overwritten to make a customized saving of the items according
to the interests of the user}
\end{quote}

Method that runs only once, once all the images have been processed. Useful for writing csv with image
annotations. By default the annotations of all images are saved in the same file. The csv file will have one
row for each generated element, identified by its id. Each column will correspond with the labels associated
to each generated element. In the case of coordinate lists, their coordinates are arranged in columns
separating the x and y coordinates in each element (point0\_x, point0\_y, point1\_x, …, point\_y)

\end{fulllineitems}

\index{save\_item() (ida\_lib.image\_augmentation.augment\_to\_disk.AugmentToDisk method)@\spxentry{save\_item()}\spxextra{ida\_lib.image\_augmentation.augment\_to\_disk.AugmentToDisk method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.image_augmentation:ida_lib.image_augmentation.augment_to_disk.AugmentToDisk.save_item}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save\_item}}}{\emph{\DUrole{n}{item}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{index}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{output\_path}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{types\_2d}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{other\_types}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{element}\DUrole{p}{:} \DUrole{n}{int}}}{}~\begin{quote}

\sphinxstylestrong{This method can be overwritten to make a customized saving of the items according
to the interests of the user}
\end{quote}

Method that implements the way to save to disk each of the generated elements. By default it saves all the
generated images in the specified path. The samples are organized by name following the form:
\begin{itemize}
\item {} 
images:                       \textless{}id\_image\textgreater{}\_\textless{}sample number\textgreater{} \textless{}extension\textgreater{}

\item {} 
other two\sphinxhyphen{}dimensional types:  \textless{}id\_image\textgreater{}\sphinxhyphen{}\textless{}data\_type\textgreater{}\_\textless{}sample number\textgreater{} \textless{}extension\textgreater{}

\end{itemize}

Annotations on the data, such as labels, or point coordinates are stored in dictionaries that will be written
when all  the images have been processed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{item}} \textendash{} input element to be saved to disk

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{element}} \textendash{} input element number to identify it

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} sample number to which the input item corresponds

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_path}} \textendash{} path to the directory in which to save the generated data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{types\_2d}} \textendash{} list of types of two dimensional data of the input item

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{other\_types}} \textendash{} list of types that are not two\sphinxhyphen{}dimensional elements

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{ida\_lib.image\_augmentation.data\_loader module}
\label{\detokenize{ida_lib.image_augmentation:module-ida_lib.image_augmentation.data_loader}}\label{\detokenize{ida_lib.image_augmentation:ida-lib-image-augmentation-data-loader-module}}\index{module@\spxentry{module}!ida\_lib.image\_augmentation.data\_loader@\spxentry{ida\_lib.image\_augmentation.data\_loader}}\index{ida\_lib.image\_augmentation.data\_loader@\spxentry{ida\_lib.image\_augmentation.data\_loader}!module@\spxentry{module}}\index{AugmentDataLoader (class in ida\_lib.image\_augmentation.data\_loader)@\spxentry{AugmentDataLoader}\spxextra{class in ida\_lib.image\_augmentation.data\_loader}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.image_augmentation:ida_lib.image_augmentation.data_loader.AugmentDataLoader}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ida\_lib.image\_augmentation.data\_loader.}}\sphinxbfcode{\sphinxupquote{AugmentDataLoader}}}{\emph{\DUrole{n}{batch\_size}}, \emph{\DUrole{n}{dataset}\DUrole{p}{:} \DUrole{n}{torch.utils.data.dataset.Dataset}}, \emph{\DUrole{n}{shuffle}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{pipeline\_operations}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{resize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{interpolation}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}bilinear\textquotesingle{}}}, \emph{\DUrole{n}{padding\_mode}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}zeros\textquotesingle{}}}, \emph{\DUrole{n}{output\_format}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}dict\textquotesingle{}}}, \emph{\DUrole{n}{output\_type}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}torch.dtype\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{torch.utils.data.dataloader.DataLoader}}
\begin{description}
\item[{The DataAugmentDataLoader class implements a Pytorch DataLoader but groups it into one class:}] \leavevmode\begin{itemize}
\item {} 
The Dataset object that takes care of reading the data

\item {} 
The iterative DataLoader object that will serve as an input system for a neural network.

\item {} 
A pipeline that applies data image Augmentation operations over the input data.

\end{itemize}

\end{description}

To make use of this class, it is necessary to provide a dataset to make a personalized reading of your data.
\index{AugmentDataLoader.InnerDataset (class in ida\_lib.image\_augmentation.data\_loader)@\spxentry{AugmentDataLoader.InnerDataset}\spxextra{class in ida\_lib.image\_augmentation.data\_loader}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.image_augmentation:ida_lib.image_augmentation.data_loader.AugmentDataLoader.InnerDataset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{InnerDataset}}}{\emph{\DUrole{n}{pipeline}}, \emph{\DUrole{n}{dataset}}}{}
Bases: \sphinxcode{\sphinxupquote{torch.utils.data.dataset.Dataset}}

inner dataset is an internal class that uses the DataAugmentDataLoader to add the pipeline to the input dataset

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{ida_lib.image_augmentation:module-ida_lib.image_augmentation}}\label{\detokenize{ida_lib.image_augmentation:module-contents}}\index{module@\spxentry{module}!ida\_lib.image\_augmentation@\spxentry{ida\_lib.image\_augmentation}}\index{ida\_lib.image\_augmentation@\spxentry{ida\_lib.image\_augmentation}!module@\spxentry{module}}

\subsubsection{ida\_lib.operations package}
\label{\detokenize{ida_lib.operations:ida-lib-operations-package}}\label{\detokenize{ida_lib.operations::doc}}

\paragraph{Submodules}
\label{\detokenize{ida_lib.operations:submodules}}

\paragraph{ida\_lib.operations.geometry\_ops\_functional module}
\label{\detokenize{ida_lib.operations:module-ida_lib.operations.geometry_ops_functional}}\label{\detokenize{ida_lib.operations:ida-lib-operations-geometry-ops-functional-module}}\index{module@\spxentry{module}!ida\_lib.operations.geometry\_ops\_functional@\spxentry{ida\_lib.operations.geometry\_ops\_functional}}\index{ida\_lib.operations.geometry\_ops\_functional@\spxentry{ida\_lib.operations.geometry\_ops\_functional}!module@\spxentry{module}}\index{affine\_compose\_data() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{affine\_compose\_data()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.affine_compose_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{affine\_compose\_data}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{matrix}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ dict}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{matrix}} \textendash{} matrix of transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{affine\_coordinates\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{affine\_coordinates\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.affine_coordinates_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{affine\_coordinates\_matrix}}}{\emph{\DUrole{n}{matrix\_coordinates}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{matrix\_transformation}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{affine\_image() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{affine\_image()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.affine_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{affine\_image}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{matrix}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{interpolation}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}bilinear\textquotesingle{}}}, \emph{\DUrole{n}{padding\_mode}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}zeros\textquotesingle{}}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{config\_scale\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{config\_scale\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.config_scale_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{config\_scale\_matrix}}}{\emph{\DUrole{n}{scale\_factor}}, \emph{\DUrole{n}{center}}, \emph{\DUrole{n}{matrix}}}{}
\end{fulllineitems}

\index{get\_rotation\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{get\_rotation\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.get_rotation_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{get\_rotation\_matrix}}}{\emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{degrees}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{}
\end{fulllineitems}

\index{get\_scale\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{get\_scale\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.get_scale_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{get\_scale\_matrix}}}{\emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{scale\_factor}\DUrole{p}{:} \DUrole{n}{Union{[}float, None.\_VariableFunctionsClass.tensor{]}}}}{}
\end{fulllineitems}

\index{get\_shear\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{get\_shear\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.get_shear_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{get\_shear\_matrix}}}{\emph{\DUrole{n}{shear\_factor}\DUrole{p}{:} \DUrole{n}{tuple}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{get\_squared\_scale\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{get\_squared\_scale\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.get_squared_scale_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{get\_squared\_scale\_matrix}}}{\emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{scale\_factor}\DUrole{p}{:} \DUrole{n}{Union{[}float, None.\_VariableFunctionsClass.tensor{]}}}}{}
\end{fulllineitems}

\index{get\_squared\_shear\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{get\_squared\_shear\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.get_squared_shear_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{get\_squared\_shear\_matrix}}}{\emph{\DUrole{n}{shear\_factor}\DUrole{p}{:} \DUrole{n}{tuple}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{get\_translation\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{get\_translation\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.get_translation_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{get\_translation\_matrix}}}{\emph{\DUrole{n}{translation}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{hflip\_compose\_data() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{hflip\_compose\_data()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.hflip_compose_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{hflip\_compose\_data}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}}{{ $\rightarrow$ dict}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{hflip\_coordinates\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{hflip\_coordinates\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.hflip_coordinates_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{hflip\_coordinates\_matrix}}}{\emph{\DUrole{n}{matrix}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{width}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{hflip\_image() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{hflip\_image()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.hflip_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{hflip\_image}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{own\_affine() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{own\_affine()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.own_affine}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{own\_affine}}}{\emph{\DUrole{n}{tensor}\DUrole{p}{:} \DUrole{n}{torch.Tensor}}, \emph{\DUrole{n}{matrix}\DUrole{p}{:} \DUrole{n}{torch.Tensor}}, \emph{\DUrole{n}{interpolation}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}bilinear\textquotesingle{}}}, \emph{\DUrole{n}{padding\_mode}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}border\textquotesingle{}}}}{{ $\rightarrow$ torch.Tensor}}
Apply an affine transformation to the image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tensor}} \textendash{} The image tensor to be warped.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{matrix}} \textendash{} The 2x3 affine transformation matrix.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{interpolation}} \textendash{} interpolation mode to calculate output values
‘bilinear’ | ‘nearest’. Default: ‘bilinear’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{padding\_mode}} \textendash{} padding mode for outside grid values
‘zeros’ | ‘border’ | ‘reflection’. Default: ‘zeros’.

\end{itemize}

\item[{Returns}] \leavevmode
The warped image.

\end{description}\end{quote}

\end{fulllineitems}

\index{prepare\_data() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{prepare\_data()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.prepare_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{prepare\_data}}}{\emph{\DUrole{n}{func}}}{}
Decorator that prepares the input data to apply the geometric transformation. For this purpose, it concatenates all
the two\sphinxhyphen{}dimensional elements of the input data in the same tensor on which a single transformation is applied.  If
the input data contains point coordinates, they are grouped in a matrix as homogeneous coordinates, over which a
single matrix multiplication is performed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{func}} \textendash{} geometric function to be applied to the data

\item[{Returns}] \leavevmode
processed data

\end{description}\end{quote}

\end{fulllineitems}

\index{rotate\_compose\_data() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{rotate\_compose\_data()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.rotate_compose_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{rotate\_compose\_data}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{degrees}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{degrees}} \textendash{} counterclockwise degrees of rotation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} \textendash{} center of rotation. Default, center of the image

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{rotate\_coordinates\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{rotate\_coordinates\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.rotate_coordinates_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{rotate\_coordinates\_matrix}}}{\emph{\DUrole{n}{matrix\_coordinates}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{matrix}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{rotate\_image() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{rotate\_image()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.rotate_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{rotate\_image}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{degrees}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
mode

\end{fulllineitems}

\index{scale\_compose\_data() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{scale\_compose\_data()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.scale_compose_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{scale\_compose\_data}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{scale\_factor}\DUrole{p}{:} \DUrole{n}{Union{[}float, None.\_VariableFunctionsClass.tensor{]}}}, \emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{Optional{[}None.\_VariableFunctionsClass.tensor{]}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ dict}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale\_factor}} \textendash{} factor of scaling

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} \textendash{} center of scaling. By default its taken the center of the image

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{scale\_coordinates\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{scale\_coordinates\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.scale_coordinates_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{scale\_coordinates\_matrix}}}{\emph{\DUrole{n}{matrix\_coordinates}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{matrix}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{scale\_image() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{scale\_image()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.scale_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{scale\_image}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{scale\_factor}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{shear\_compose\_data() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{shear\_compose\_data()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.shear_compose_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{shear\_compose\_data}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{shear\_factor}\DUrole{p}{:} \DUrole{n}{tuple}}}{{ $\rightarrow$ dict}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shear\_factor}} \textendash{} pixels of shearing

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{shear\_coordinates\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{shear\_coordinates\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.shear_coordinates_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{shear\_coordinates\_matrix}}}{\emph{\DUrole{n}{matrix\_coordinates}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{matrix}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{shear\_image() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{shear\_image()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.shear_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{shear\_image}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{shear\_factor}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{translate\_compose\_data() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{translate\_compose\_data()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.translate_compose_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{translate\_compose\_data}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{translation}\DUrole{p}{:} \DUrole{n}{Union{[}int, None.\_VariableFunctionsClass.tensor{]}}}}{{ $\rightarrow$ dict}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{translation}} \textendash{} number of pixels to translate

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{translate\_coordinates\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{translate\_coordinates\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.translate_coordinates_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{translate\_coordinates\_matrix}}}{\emph{\DUrole{n}{matrix\_coordinates}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{translation}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{translate\_image() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{translate\_image()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.translate_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{translate\_image}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{translation}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{vflip\_compose\_data() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{vflip\_compose\_data()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.vflip_compose_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{vflip\_compose\_data}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}}{{ $\rightarrow$ dict}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{vflip\_coordinates\_matrix() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{vflip\_coordinates\_matrix()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.vflip_coordinates_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{vflip\_coordinates\_matrix}}}{\emph{\DUrole{n}{matrix}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{height}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}

\index{vflip\_image() (in module ida\_lib.operations.geometry\_ops\_functional)@\spxentry{vflip\_image()}\spxextra{in module ida\_lib.operations.geometry\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.geometry_ops_functional.vflip_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.geometry\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{vflip\_image}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}}{{ $\rightarrow$ None.\_VariableFunctionsClass.tensor}}
\end{fulllineitems}



\paragraph{ida\_lib.operations.pixel\_ops\_functional module}
\label{\detokenize{ida_lib.operations:module-ida_lib.operations.pixel_ops_functional}}\label{\detokenize{ida_lib.operations:ida-lib-operations-pixel-ops-functional-module}}\index{module@\spxentry{module}!ida\_lib.operations.pixel\_ops\_functional@\spxentry{ida\_lib.operations.pixel\_ops\_functional}}\index{ida\_lib.operations.pixel\_ops\_functional@\spxentry{ida\_lib.operations.pixel\_ops\_functional}!module@\spxentry{module}}\index{apply\_blur() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{apply\_blur()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.apply_blur}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{apply\_blur}}}{\emph{\DUrole{n}{img}}, \emph{\DUrole{n}{blur\_size}\DUrole{o}{=}\DUrole{default_value}{5, 5}}}{}
\end{fulllineitems}

\index{apply\_gaussian\_blur() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{apply\_gaussian\_blur()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.apply_gaussian_blur}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{apply\_gaussian\_blur}}}{\emph{\DUrole{n}{img}}, \emph{\DUrole{n}{blur\_size}\DUrole{o}{=}\DUrole{default_value}{5, 5}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{img}} \textendash{} input image to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{blur\_size}} \textendash{} number of surrounding pixels affecting each output pixel. (pixels on axis X, pixels on axis y)

\end{itemize}

\item[{Returns}] \leavevmode
returns the transformed image

\end{description}\end{quote}

\end{fulllineitems}

\index{apply\_gaussian\_noise() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{apply\_gaussian\_noise()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.apply_gaussian_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{apply\_gaussian\_noise}}}{\emph{\DUrole{n}{image}}, \emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{20}}}{}
\end{fulllineitems}

\index{apply\_lut\_by\_pixel\_function() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{apply\_lut\_by\_pixel\_function()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.apply_lut_by_pixel_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{apply\_lut\_by\_pixel\_function}}}{\emph{\DUrole{n}{function}}, \emph{\DUrole{n}{image}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
Applies the input operation to the image using a LUT
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{function}} \textendash{} Mathematical function that represents the operation to carry out in each pixel of the image

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{image}} \textendash{} input image

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{apply\_poisson\_noise() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{apply\_poisson\_noise()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.apply_poisson_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{apply\_poisson\_noise}}}{\emph{\DUrole{n}{image}}}{}
\end{fulllineitems}

\index{apply\_salt\_and\_pepper\_noise() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{apply\_salt\_and\_pepper\_noise()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.apply_salt_and_pepper_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{apply\_salt\_and\_pepper\_noise}}}{\emph{\DUrole{n}{image}}, \emph{\DUrole{n}{amount}\DUrole{o}{=}\DUrole{default_value}{0.05}}, \emph{\DUrole{n}{s\_vs\_p}\DUrole{o}{=}\DUrole{default_value}{0.5}}}{}
\end{fulllineitems}

\index{apply\_spekle\_noise() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{apply\_spekle\_noise()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.apply_spekle_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{apply\_spekle\_noise}}}{\emph{\DUrole{n}{image}}, \emph{\DUrole{n}{mean}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{0.01}}}{}
\end{fulllineitems}

\index{blur() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{blur()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.blur}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{blur}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}, \emph{\DUrole{n}{blur\_size}}}{{ $\rightarrow$ Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{img}} \textendash{} input image to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{blur\_size}} \textendash{} number of surrounding pixels affecting each output pixel. (pixels on axis X, pixels on axis y)

\end{itemize}

\item[{Returns}] \leavevmode
returns the transformed image

\end{description}\end{quote}

\end{fulllineitems}

\index{change\_brightness() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{change\_brightness()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.change_brightness}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{change\_brightness}}}{\emph{\DUrole{n}{image}\DUrole{p}{:} \DUrole{n}{Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}, \emph{\DUrole{n}{brightness}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}
Change the brightness of the input image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{image}} \textendash{} input image to be normalized

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{brightness}} \textendash{} desired amount of brightness for the image
0 \sphinxhyphen{} no brightness
1 \sphinxhyphen{} same
2 \sphinxhyphen{} max brightness

\end{itemize}

\item[{Returns}] \leavevmode
transformed image

\end{description}\end{quote}

\end{fulllineitems}

\index{change\_contrast() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{change\_contrast()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.change_contrast}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{change\_contrast}}}{\emph{\DUrole{n}{image}\DUrole{p}{:} \DUrole{n}{Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}, \emph{\DUrole{n}{contrast}}}{{ $\rightarrow$ Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}
:param image  : input image to be transformed
:param contrast: modification factor to be applied to the image contrast
\begin{itemize}
\item {} 
0  \sphinxhyphen{} total contrast removal

\item {} 
1  \sphinxhyphen{} dont modify

\item {} 
\textgreater{}1 \sphinxhyphen{} augment contrast

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
returns the transformed image

\end{description}\end{quote}

\end{fulllineitems}

\index{change\_gamma() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{change\_gamma()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.change_gamma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{change\_gamma}}}{\emph{\DUrole{n}{image}\DUrole{p}{:} \DUrole{n}{Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}, \emph{\DUrole{n}{gamma}\DUrole{p}{:} \DUrole{n}{float}}}{{ $\rightarrow$ Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{image}} \textendash{} input image to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} \textendash{} desired factor gamma
* gamma = 0 \sphinxhyphen{}\textgreater{} removes image luminance (black output image)
* gamma = 1 \sphinxhyphen{}\textgreater{} remains unchanged
* gamma \textgreater{} 1 \sphinxhyphen{}\textgreater{} increases luminance

\end{itemize}

\item[{Returns}] \leavevmode
returns the transformed image

\end{description}\end{quote}

\end{fulllineitems}

\index{gaussian\_blur() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{gaussian\_blur()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.gaussian_blur}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{gaussian\_blur}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}, \emph{\DUrole{n}{blur\_size}}}{{ $\rightarrow$ Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{img}} \textendash{} input image to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{blur\_size}} \textendash{} number of surrounding pixels affecting each output pixel. (pixels on axis X, pixels on axis y)

\end{itemize}

\item[{Returns}] \leavevmode
returns the transformed image

\end{description}\end{quote}

\end{fulllineitems}

\index{gaussian\_noise() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{gaussian\_noise()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.gaussian_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{gaussian\_noise}}}{\emph{\DUrole{n}{image}\DUrole{p}{:} \DUrole{n}{Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}, \emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{20}}}{{ $\rightarrow$ Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{image}} \textendash{} input image to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{var}} \textendash{} var of the gaussian distribution of noise

\end{itemize}

\item[{Returns}] \leavevmode
returns the transformed image

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_brightness\_function() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{get\_brightness\_function()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.get_brightness_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{get\_brightness\_function}}}{\emph{\DUrole{n}{brightness}\DUrole{p}{:} \DUrole{n}{int}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{brightness}} \textendash{} brightness factor

\item[{Returns}] \leavevmode
Return the lambda function of the brightness operation

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_contrast\_function() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{get\_contrast\_function()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.get_contrast_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{get\_contrast\_function}}}{\emph{\DUrole{n}{contrast}\DUrole{p}{:} \DUrole{n}{float}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{contrast}} \textendash{} modification factor to be applied to the image contrast

\item[{Returns}] \leavevmode
Return the lambda function of the contrast operation

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_gamma\_function() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{get\_gamma\_function()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.get_gamma_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{get\_gamma\_function}}}{\emph{\DUrole{n}{gamma}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} \textendash{} desired factor gamma

\item[{Returns}] \leavevmode
Returns the lambda function of the gamma adjust operation

\end{description}\end{quote}

\end{fulllineitems}

\index{histogram\_equalization() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{histogram\_equalization()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.histogram_equalization}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{histogram\_equalization}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}}{{ $\rightarrow$ Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{img}} \textendash{} input image to be transformed

\item[{Returns}] \leavevmode
returns the transformed image

\end{description}\end{quote}

\end{fulllineitems}

\index{normalize\_image() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{normalize\_image()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.normalize_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{normalize\_image}}}{\emph{\DUrole{n}{img}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{norm\_type}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{32}}}{{ $\rightarrow$ numpy.ndarray}}
Normalize the input image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{img}} \textendash{} input image to be normalized

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{norm\_type}} \textendash{} opencv normalization type (‘ cv2.NORM\_MINMAX’ {\color{red}\bfseries{}|}cv2.NORM\_HAMMING {\color{red}\bfseries{}|}cv2.NORM\_HAMMING2
{\color{red}\bfseries{}|}cv2.NORM\_INF {\color{red}\bfseries{}|}cv2.NORM\_RELATIVE …)

\end{itemize}

\item[{Returns}] \leavevmode
normalized image

\end{description}\end{quote}

\end{fulllineitems}

\index{poisson\_noise() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{poisson\_noise()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.poisson_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{poisson\_noise}}}{\emph{\DUrole{n}{image}\DUrole{p}{:} \DUrole{n}{Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}}{{ $\rightarrow$ Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{image}} \textendash{} input image to be transformed

\item[{Returns}] \leavevmode
returns the transformed image

\end{description}\end{quote}

\end{fulllineitems}

\index{prepare\_data\_for\_opencv() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{prepare\_data\_for\_opencv()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.prepare_data_for_opencv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{prepare\_data\_for\_opencv}}}{\emph{\DUrole{n}{func}}}{}
Decorator that prepares the input data to apply the transformation that only affects the image (color).
:param func: color function to be applied to the data
:return: processed data

\end{fulllineitems}

\index{salt\_and\_pepper\_noise() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{salt\_and\_pepper\_noise()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.salt_and_pepper_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{salt\_and\_pepper\_noise}}}{\emph{\DUrole{n}{image}\DUrole{p}{:} \DUrole{n}{Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}, \emph{\DUrole{n}{amount}}, \emph{\DUrole{n}{s\_vs\_p}}}{{ $\rightarrow$ Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{image}} \textendash{} input image to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{amount}} \textendash{} percentage of image’s pixels to be occupied by noise

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{s\_vs\_p}} \textendash{} percentage of salt respect total noise. Default same salt (white pixel) as pepper (black pixels)

\end{itemize}

\item[{Returns}] \leavevmode
returns the transformed image

\end{description}\end{quote}

\end{fulllineitems}

\index{spekle\_noise() (in module ida\_lib.operations.pixel\_ops\_functional)@\spxentry{spekle\_noise()}\spxextra{in module ida\_lib.operations.pixel\_ops\_functional}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.pixel_ops_functional.spekle_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.pixel\_ops\_functional.}}\sphinxbfcode{\sphinxupquote{spekle\_noise}}}{\emph{\DUrole{n}{image}\DUrole{p}{:} \DUrole{n}{Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}, \emph{\DUrole{n}{mean}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{0.01}}}{{ $\rightarrow$ Union{[}dict, None.\_VariableFunctionsClass.tensor, numpy.ndarray{]}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{image}} \textendash{} input image to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mean}} \textendash{} mean of noise distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{var}} \textendash{} variance of noise distribution

\end{itemize}

\item[{Returns}] \leavevmode
returns the transformed image

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ida\_lib.operations.transforms module}
\label{\detokenize{ida_lib.operations:module-ida_lib.operations.transforms}}\label{\detokenize{ida_lib.operations:ida-lib-operations-transforms-module}}\index{module@\spxentry{module}!ida\_lib.operations.transforms@\spxentry{ida\_lib.operations.transforms}}\index{ida\_lib.operations.transforms@\spxentry{ida\_lib.operations.transforms}!module@\spxentry{module}}\index{hflip() (in module ida\_lib.operations.transforms)@\spxentry{hflip()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.hflip}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{hflip}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ dict}}~\begin{quote}

Horizontally flip the input data.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{vflip() (in module ida\_lib.operations.transforms)@\spxentry{vflip()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.vflip}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{vflip}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ dict}}~\begin{quote}

Vertically  flip the input data.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{affine() (in module ida\_lib.operations.transforms)@\spxentry{affine()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.affine}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{affine}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{matrix}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ dict}}~\begin{quote}

Applies affine transformation to the data
\end{quote}

:param data  dict of elements to be transformed
:param matrix: matrix of transformation
:param visualize: if true it activates the display tool to debug the transformation
:return: transformed data

\end{fulllineitems}

\index{rotate() (in module ida\_lib.operations.transforms)@\spxentry{rotate()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.rotate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{rotate}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{degrees}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{Union{[}None, torch.Tensor{]}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ dict}}~\begin{quote}

Rotate each element of the input data by the indicated degrees counterclockwise
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{degrees}} \textendash{} degrees of rotation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} \textendash{} center of rotation. If center is None, it is taken the center of the image to apply the rotation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{shear() (in module ida\_lib.operations.transforms)@\spxentry{shear()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.shear}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{shear}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{shear\_factor}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ dict}}~\begin{quote}

Shear input data by the input shear factor
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shear\_factor}} \textendash{} pixels to shear

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{scale() (in module ida\_lib.operations.transforms)@\spxentry{scale()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.scale}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{scale}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{scale\_factor}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{center}\DUrole{p}{:} \DUrole{n}{Union{[}None, torch.Tensor{]}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ dict}}~\begin{quote}

Scale each element of the input data by the input factor.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale\_factor}} \textendash{} factor of scaling to be applied
* scale\_factor \textless{} 1 \sphinxhyphen{}\textgreater{} output image is smaller than input one
* scale\_factor = 1 \sphinxhyphen{}\textgreater{} output image is is the same as the input image
* scale\_factor = 2 \sphinxhyphen{}\textgreater{} each original pixel occupies 2 pixels in the output image

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} \textendash{} center of scaling. If center is None, it is taken the center of the image to apply the scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{translate() (in module ida\_lib.operations.transforms)@\spxentry{translate()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.translate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{translate}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{translation}\DUrole{p}{:} \DUrole{n}{tuple}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ dict}}~\begin{quote}

Translate input by the input translation.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{translation}} \textendash{} number of pixels to be translated

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{change\_gamma() (in module ida\_lib.operations.transforms)@\spxentry{change\_gamma()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.change_gamma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{change\_gamma}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{gamma}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}~\begin{quote}

Adjust image’s gamma (luminance correction) . if the input data is a dictionary, only those corresponding
\end{quote}

to an image are altered
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} \textendash{} 
desired gamma factor (luminance of image)
\begin{itemize}
\item {} 
gamma = 0 \sphinxhyphen{}\textgreater{} removes image luminance (black output image)

\item {} 
gamma = 1 \sphinxhyphen{}\textgreater{} remains unchanged

\item {} 
gamma \textgreater{} 1 \sphinxhyphen{}\textgreater{} increases luminance

\end{itemize}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{change\_contrast() (in module ida\_lib.operations.transforms)@\spxentry{change\_contrast()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.change_contrast}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{change\_contrast}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{contrast}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}~\begin{quote}

Change the image contrast. if the input data is a dictionary, only those corresponding to an image are altered
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{contrast}} \textendash{} desired contrast factor to the data
* contrast = 0 \sphinxhyphen{}\textgreater{} removes image contrast (white output image)
* contrast = 1 \sphinxhyphen{}\textgreater{} remains unchanged
* contrast \textgreater{} 1 \sphinxhyphen{}\textgreater{} increases contrast

\end{itemize}

\end{description}\end{quote}

:param visualize  : if true it activates the display tool to debug the transformation
:return: transformed data

\end{fulllineitems}

\index{change\_brightness() (in module ida\_lib.operations.transforms)@\spxentry{change\_brightness()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.change_brightness}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{change\_brightness}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{bright}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}~\begin{quote}

Change the image brightness. if the input data is a dictionary, only those corresponding to an image are altered
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bright}} \textendash{} 
desired brightness amount for the data
\begin{itemize}
\item {} 
brightness = 0 \sphinxhyphen{}\textgreater{} removes image brightness (black output image)

\item {} 
brightness = 1 \sphinxhyphen{}\textgreater{} remains unchanged

\item {} 
brightness \textgreater{} 1 \sphinxhyphen{}\textgreater{} increases brightness

\end{itemize}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{equalize\_histogram() (in module ida\_lib.operations.transforms)@\spxentry{equalize\_histogram()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.equalize_histogram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{equalize\_histogram}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}~\begin{quote}

Equalize image histogram. if the input data is a dictionary, only those corresponding to an image are altered
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{inject\_gaussian\_noise() (in module ida\_lib.operations.transforms)@\spxentry{inject\_gaussian\_noise()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.inject_gaussian_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{inject\_gaussian\_noise}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}~\begin{quote}

Inject gaussian noise. If the input data is a dictionary, only those corresponding to an image are altered
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{var}} \textendash{} variance of the noise distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{inject\_poisson\_noise() (in module ida\_lib.operations.transforms)@\spxentry{inject\_poisson\_noise()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.inject_poisson_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{inject\_poisson\_noise}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
Inject poisson noise. if the input data is a dictionary, only those corresponding to an image are altered
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{inject\_spekle\_noise() (in module ida\_lib.operations.transforms)@\spxentry{inject\_spekle\_noise()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.inject_spekle_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{inject\_spekle\_noise}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{mean}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{var}\DUrole{o}{=}\DUrole{default_value}{0.01}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
Inject poisson noise. if the input data is a dictionary, only those corresponding to an image are altered
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mean}} \textendash{} mean of noise distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{var}} \textendash{} variance of noise distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{inject\_salt\_and\_pepper\_noise() (in module ida\_lib.operations.transforms)@\spxentry{inject\_salt\_and\_pepper\_noise()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.inject_salt_and_pepper_noise}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{inject\_salt\_and\_pepper\_noise}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{amount}\DUrole{o}{=}\DUrole{default_value}{0.05}}, \emph{\DUrole{n}{s\_vs\_p}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
Inject salt and pepper noise if the input data is a dictionary, only those corresponding to an image are altered
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{amount}} \textendash{} percentage of image’s pixels to be occupied by noise

\end{itemize}

\end{description}\end{quote}

:param s\_vs\_p : noise type distribution. Default same salt (white pixel) as pepper (black pixels)
:param visualize: if true it activates the display tool to debug the transformation
:return: transformed data

\end{fulllineitems}

\index{blur() (in module ida\_lib.operations.transforms)@\spxentry{blur()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.blur}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{blur}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{blur\_size}\DUrole{o}{=}\DUrole{default_value}{5, 5}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
Blur image.  if the input data is a dictionary, only those corresponding to an image are altered
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{blur\_size}} \textendash{} number of surrounding pixels affecting each output pixel. (pixels on axis X, pixels on axis y)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}

\index{gaussian\_blur() (in module ida\_lib.operations.transforms)@\spxentry{gaussian\_blur()}\spxextra{in module ida\_lib.operations.transforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.transforms.gaussian_blur}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.transforms.}}\sphinxbfcode{\sphinxupquote{gaussian\_blur}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{blur\_size}\DUrole{o}{=}\DUrole{default_value}{5, 5}}, \emph{\DUrole{n}{visualize}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{, }torch.Tensor\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
Blurring an image by a Gaussian function.  if the input data is a dictionary, only those corresponding to an
image are altered
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} dict of elements to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{blur\_size}} \textendash{} number of surrounding pixels affecting each output pixel. (pixels on axis X, pixels on axis y)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualize}} \textendash{} if true it activates the display tool to debug the transformation

\end{itemize}

\item[{Returns}] \leavevmode
transformed data

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{ida\_lib.operations.utils module}
\label{\detokenize{ida_lib.operations:module-ida_lib.operations.utils}}\label{\detokenize{ida_lib.operations:ida-lib-operations-utils-module}}\index{module@\spxentry{module}!ida\_lib.operations.utils@\spxentry{ida\_lib.operations.utils}}\index{ida\_lib.operations.utils@\spxentry{ida\_lib.operations.utils}!module@\spxentry{module}}\index{add\_new\_axis() (in module ida\_lib.operations.utils)@\spxentry{add\_new\_axis()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.add_new_axis}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{add\_new\_axis}}}{\emph{\DUrole{n}{arr}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
\end{fulllineitems}

\index{arrays\_equal() (in module ida\_lib.operations.utils)@\spxentry{arrays\_equal()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.arrays_equal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{arrays\_equal}}}{\emph{\DUrole{n}{arr1}}, \emph{\DUrole{n}{arr2}}}{}
\end{fulllineitems}

\index{data\_to\_numpy() (in module ida\_lib.operations.utils)@\spxentry{data\_to\_numpy()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.data_to_numpy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{data\_to\_numpy}}}{\emph{\DUrole{n}{data}}}{}
\end{fulllineitems}

\index{dtype\_to\_torch\_type() (in module ida\_lib.operations.utils)@\spxentry{dtype\_to\_torch\_type()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.dtype_to_torch_type}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{dtype\_to\_torch\_type}}}{\emph{\DUrole{n}{im\_type}\DUrole{p}{:} \DUrole{n}{numpy.dtype}}}{}
Maps the numpy type to the equivalent torch.type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{im\_type}} \textendash{} numpy type

\item[{Returns}] \leavevmode
torch.type

\end{description}\end{quote}

\end{fulllineitems}

\index{element\_to\_dict\_csv\_format() (in module ida\_lib.operations.utils)@\spxentry{element\_to\_dict\_csv\_format()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.element_to_dict_csv_format}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{element\_to\_dict\_csv\_format}}}{\emph{\DUrole{n}{item}}, \emph{\DUrole{n}{name}}}{}
\end{fulllineitems}

\index{get\_principal\_type() (in module ida\_lib.operations.utils)@\spxentry{get\_principal\_type()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.get_principal_type}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{get\_principal\_type}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{dict}}}{}
\end{fulllineitems}

\index{get\_torch\_image\_center() (in module ida\_lib.operations.utils)@\spxentry{get\_torch\_image\_center()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.get_torch_image_center}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{get\_torch\_image\_center}}}{\emph{\DUrole{n}{data}}}{}
\end{fulllineitems}

\index{homogeneous\_points\_to\_list() (in module ida\_lib.operations.utils)@\spxentry{homogeneous\_points\_to\_list()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.homogeneous_points_to_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{homogeneous\_points\_to\_list}}}{\emph{\DUrole{n}{keypoints}}}{}
\end{fulllineitems}

\index{homogeneous\_points\_to\_matrix() (in module ida\_lib.operations.utils)@\spxentry{homogeneous\_points\_to\_matrix()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.homogeneous_points_to_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{homogeneous\_points\_to\_matrix}}}{\emph{\DUrole{n}{keypoints}}}{}
\end{fulllineitems}

\index{is\_a\_normalized\_image() (in module ida\_lib.operations.utils)@\spxentry{is\_a\_normalized\_image()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.is_a_normalized_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{is\_a\_normalized\_image}}}{\emph{\DUrole{n}{image}}}{}
\end{fulllineitems}

\index{is\_numpy\_data() (in module ida\_lib.operations.utils)@\spxentry{is\_numpy\_data()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.is_numpy_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{is\_numpy\_data}}}{\emph{\DUrole{n}{data}}}{}
\end{fulllineitems}

\index{keypoints\_to\_homogeneous\_and\_concatenate() (in module ida\_lib.operations.utils)@\spxentry{keypoints\_to\_homogeneous\_and\_concatenate()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.keypoints_to_homogeneous_and_concatenate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{keypoints\_to\_homogeneous\_and\_concatenate}}}{\emph{\DUrole{n}{keypoints}}, \emph{\DUrole{n}{resize\_factor}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\end{fulllineitems}

\index{keypoints\_to\_homogeneous\_functional() (in module ida\_lib.operations.utils)@\spxentry{keypoints\_to\_homogeneous\_functional()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.keypoints_to_homogeneous_functional}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{keypoints\_to\_homogeneous\_functional}}}{\emph{\DUrole{n}{keypoints}}}{}
\end{fulllineitems}

\index{map\_value() (in module ida\_lib.operations.utils)@\spxentry{map\_value()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.map_value}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{map\_value}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{in\_min}}, \emph{\DUrole{n}{in\_max}}, \emph{\DUrole{n}{out\_min}}, \emph{\DUrole{n}{out\_max}}}{}
\end{fulllineitems}

\index{mask\_change\_to\_01\_functional() (in module ida\_lib.operations.utils)@\spxentry{mask\_change\_to\_01\_functional()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.mask_change_to_01_functional}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{mask\_change\_to\_01\_functional}}}{\emph{\DUrole{n}{mask}}}{}
\end{fulllineitems}

\index{remove\_digits() (in module ida\_lib.operations.utils)@\spxentry{remove\_digits()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.remove_digits}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{remove\_digits}}}{\emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{str}}}{}
\end{fulllineitems}

\index{round\_torch() (in module ida\_lib.operations.utils)@\spxentry{round\_torch()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.round_torch}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{round\_torch}}}{\emph{\DUrole{n}{arr}\DUrole{p}{:} \DUrole{n}{None.\_VariableFunctionsClass.tensor}}, \emph{\DUrole{n}{n\_digits}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{3}}}{}
\end{fulllineitems}

\index{save\_im() (in module ida\_lib.operations.utils)@\spxentry{save\_im()}\spxextra{in module ida\_lib.operations.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib.operations:ida_lib.operations.utils.save_im}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.operations.utils.}}\sphinxbfcode{\sphinxupquote{save\_im}}}{\emph{\DUrole{n}{tensor}}, \emph{\DUrole{n}{title}}}{}
\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{ida_lib.operations:module-ida_lib.operations}}\label{\detokenize{ida_lib.operations:module-contents}}\index{module@\spxentry{module}!ida\_lib.operations@\spxentry{ida\_lib.operations}}\index{ida\_lib.operations@\spxentry{ida\_lib.operations}!module@\spxentry{module}}

\subsection{Submodules}
\label{\detokenize{ida_lib:submodules}}

\subsection{ida\_lib.visualization module}
\label{\detokenize{ida_lib:module-ida_lib.visualization}}\label{\detokenize{ida_lib:ida-lib-visualization-module}}\index{module@\spxentry{module}!ida\_lib.visualization@\spxentry{ida\_lib.visualization}}\index{ida\_lib.visualization@\spxentry{ida\_lib.visualization}!module@\spxentry{module}}\index{visualize() (in module ida\_lib.visualization)@\spxentry{visualize()}\spxextra{in module ida\_lib.visualization}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib:ida_lib.visualization.visualize}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.visualization.}}\sphinxbfcode{\sphinxupquote{visualize}}}{\emph{\DUrole{n}{images}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{images\_originals}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{max\_images}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{5}}}{}
Generate the bokeh plot of the input batch transformation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{images}} \textendash{} list of transformed items (dict of image and other  objects)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{images\_originals}} \textendash{} list of original items (dict of image and other  objects)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_images}} \textendash{} max number of tabs to be shown

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_image\_transformation() (in module ida\_lib.visualization)@\spxentry{plot\_image\_transformation()}\spxextra{in module ida\_lib.visualization}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ida_lib:ida_lib.visualization.plot_image_transformation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ida\_lib.visualization.}}\sphinxbfcode{\sphinxupquote{plot\_image\_transformation}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{data\_original}}}{}
Generate the bokeh plot of the input batch transformation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} input dict element

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_original}} \textendash{} original input element (before transforms)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Examples}
\label{\detokenize{examples:examples}}\label{\detokenize{examples::doc}}
You can find all the examples here:
\sphinxurl{https://github.com/raquelvilas18/ida\_lib/tree/master/examples}


\subsection{Pipeline usage example}
\label{\detokenize{examples:pipeline-usage-example}}

\subsubsection{Pipeline Usage example}
\label{\detokenize{pipeline_example:pipeline-usage-example}}\label{\detokenize{pipeline_example::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}In this file an example of how to use the idaLib pipeline is shown, in which you can see:}
\PYG{l+s+sd}{* how to declare the pipeline}
\PYG{l+s+sd}{* which format to use for the input elements}
\PYG{l+s+sd}{* how to display or not the results}
\PYG{l+s+sd}{* and how to execute it in general.}

\PYG{l+s+sd}{For more information see the documentation}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{from} \PYG{n+nn}{time} \PYG{k+kn}{import} \PYG{n}{time}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{pipeline} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{pipeline\PYGZus{}geometric\PYGZus{}ops} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{pipeline\PYGZus{}local\PYGZus{}ops} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{data\PYGZus{}type} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{uint8}

\PYG{c+c1}{\PYGZsh{} Read the example image}
\PYG{n}{img}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray} \PYG{o}{=} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../micky.jpg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} opencv read in format BGR but IDALib works on RGB}
\PYG{n}{img} \PYG{o}{=} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{cvtColor}\PYG{p}{(}\PYG{n}{img}\PYG{p}{,} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{COLOR\PYGZus{}BGR2RGB}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}img = img.astype(\PYGZsq{}float32\PYGZsq{})  \PYGZsh{} Example of bits per pixel used}

\PYG{n}{short\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Generate an example of segmentation map over the image}
\PYG{n}{segmap} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{data\PYGZus{}type}\PYG{p}{)}
\PYG{n}{segmap}\PYG{p}{[}\PYG{l+m+mi}{28}\PYG{p}{:}\PYG{l+m+mi}{171}\PYG{p}{,} \PYG{l+m+mi}{35}\PYG{p}{:}\PYG{l+m+mi}{485}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{segmap}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{:}\PYG{l+m+mi}{245}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{segmap}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{70}\PYG{p}{:}\PYG{l+m+mi}{385}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{segmap}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{110}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{:}\PYG{l+m+mi}{210}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{segmap}\PYG{p}{[}\PYG{l+m+mi}{18}\PYG{p}{:}\PYG{l+m+mi}{223}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{110}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{c+c1}{\PYGZsh{} Generate 2 examples of masks}
\PYG{n}{mask\PYGZus{}example1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{data\PYGZus{}type}\PYG{p}{)}
\PYG{n}{mask\PYGZus{}example1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{50}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{mask\PYGZus{}example2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{data\PYGZus{}type}\PYG{p}{)}
\PYG{n}{mask\PYGZus{}example2}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{150}\PYG{p}{:}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{} Generate an example of heatmap over the image}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Create heatmap}
\PYG{n}{heatmap}\PYG{p}{,} \PYG{n}{xedges}\PYG{p}{,} \PYG{n}{yedges} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{histogram2d}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{p}{(}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{heatmap\PYGZus{}complete} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{heatmap\PYGZus{}complete}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{img}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{} Generate an example of coordinates of keypoints over the image}
\PYG{c+c1}{\PYGZsh{} the list of keypoints can be expressed as an array of nx2 dimensions or as a list of arrays (1x2) (of 2 coordinates)}
\PYG{n}{number\PYGZus{}of\PYGZus{}points} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{c+c1}{\PYGZsh{} generate 20 random coordinates (to make sure they don\PYGZsq{}t go outside the image boundaries set short\PYGZus{}Size as the limit)}
\PYG{n}{random\PYGZus{}coordinates} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{short\PYGZus{}size}\PYG{p}{,} \PYG{n}{number\PYGZus{}of\PYGZus{}points} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}points}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Generate the input item of the pipeline. Its very importantto name each element with its data type so that the}
\PYG{c+c1}{\PYGZsh{} pipeline understands them. *If the item contains more than one element of each type, just number them like mask1}
\PYG{c+c1}{\PYGZsh{} and mask2}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{img}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{keypoints}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{random\PYGZus{}coordinates}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mask1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{mask\PYGZus{}example1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mask2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{mask\PYGZus{}example2}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{heatmap}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{heatmap\PYGZus{}complete}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} For this example we are going to use the same identical input element but repeated n times to create a batch so we}
\PYG{c+c1}{\PYGZsh{} can see the different transformations}
\PYG{n}{samples} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{batch} \PYG{o}{=} \PYG{p}{[}\PYG{n}{data}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{samples}\PYG{p}{)}\PYG{p}{]}

\PYG{n}{start\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} time measurement}

\PYG{c+c1}{\PYGZsh{} Define the pipeline and operations.}
\PYG{n}{pip} \PYG{o}{=} \PYG{n}{Pipeline}\PYG{p}{(}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nearest}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
               \PYG{n}{pipeline\PYGZus{}operations}\PYG{o}{=}\PYG{p}{(}
                   \PYG{n}{ScalePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{ShearPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{shear}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{TranslatePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{translation}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{HflipPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{exchange\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{RandomRotatePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{degrees\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{GaussianNoisePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} pass the batch through the pipeline and visualize the transformations}
\PYG{n}{batch} \PYG{o}{=} \PYG{n}{pip}\PYG{p}{(}\PYG{n}{batch}\PYG{p}{,} \PYG{n}{visualize}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{consumed\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}time}
\PYG{c+c1}{\PYGZsh{} keep in mind that visualization is a significant overhead, so to take a good measure of}
\PYG{c+c1}{\PYGZsh{} performance set visualize=False}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Total time consumed to process }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{samples}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ samples: }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{consumed\PYGZus{}time}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Time per sample: :}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{consumed\PYGZus{}time} \PYG{o}{/} \PYG{n}{samples}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Dataloader Usage example}
\label{\detokenize{dataloader_example:dataloader-usage-example}}\label{\detokenize{dataloader_example::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{This file has an example of how to use IDALib\PYGZsq{}s own DataLoader which includes a pipeline to perform image data}
\PYG{l+s+sd}{augmentation on your data.}
\PYG{l+s+sd}{This code follows the pytorch example of  of using a dataloader}
\PYG{l+s+sd}{https://pytorch.org/tutorials/beginner/data\PYGZus{}loading\PYGZus{}tutorial.html  but adapted to the ida\PYGZhy{}lib dataloader}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{k+kn}{import} \PYG{n+nn}{kornia}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{from} \PYG{n+nn}{skimage} \PYG{k+kn}{import} \PYG{n}{io}

\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{pipeline\PYGZus{}geometric\PYGZus{}ops} \PYG{k+kn}{import} \PYG{n}{TranslatePipeline}\PYG{p}{,} \PYG{n}{VflipPipeline}\PYG{p}{,} \PYG{n}{HflipPipeline}\PYG{p}{,} \PYG{n}{RandomShearPipeline}
\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{pipeline\PYGZus{}pixel\PYGZus{}ops} \PYG{k+kn}{import} \PYG{n}{ContrastPipeline}
\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{image\PYGZus{}augmentation}\PYG{n+nn}{.}\PYG{n+nn}{data\PYGZus{}loader} \PYG{k+kn}{import} \PYG{o}{*}


\PYG{c+c1}{\PYGZsh{} Firstly create custom dataset to read the input data}
\PYG{k}{class} \PYG{n+nc}{FaceLandmarksDataset}\PYG{p}{(}\PYG{n}{Dataset}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Face Landmarks dataset.\PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{csv\PYGZus{}file}\PYG{p}{,} \PYG{n}{root\PYGZus{}dir}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            csv\PYGZus{}file (string): Path to the csv file with annotations.}
\PYG{l+s+sd}{            root\PYGZus{}dir (string): Directory with all the images.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{landmarks\PYGZus{}frame} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}file}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{root\PYGZus{}dir} \PYG{o}{=} \PYG{n}{root\PYGZus{}dir}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}len\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{landmarks\PYGZus{}frame}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{idx}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{is\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{idx}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{idx} \PYG{o}{=} \PYG{n}{idx}\PYG{o}{.}\PYG{n}{tolist}\PYG{p}{(}\PYG{p}{)}

        \PYG{n}{img\PYGZus{}name} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{root\PYGZus{}dir}\PYG{p}{,}
                                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{landmarks\PYGZus{}frame}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{image} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{n}{img\PYGZus{}name}\PYG{p}{)}
        \PYG{n}{landmarks} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{landmarks\PYGZus{}frame}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
        \PYG{n}{landmarks} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{landmarks}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{landmarks} \PYG{o}{=} \PYG{n}{landmarks}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{float}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n}{sample} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{landmarks\PYGZus{}frame}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{image}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{keypoints}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{landmarks}\PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{sample}


\PYG{c+c1}{\PYGZsh{} Auxiliar function to display elements}
\PYG{k}{def} \PYG{n+nf}{show\PYGZus{}landmarks}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{landmarks}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Show image with landmarks\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{img} \PYG{o}{=} \PYG{n}{kornia}\PYG{o}{.}\PYG{n}{tensor\PYGZus{}to\PYGZus{}image}\PYG{p}{(}\PYG{n}{image}\PYG{o}{.}\PYG{n}{byte}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
    \PYG{n}{landmarks} \PYG{o}{=} \PYG{n}{landmarks}\PYG{o}{.}\PYG{n}{cpu}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{landmarks}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{landmarks}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{pause}\PYG{p}{(}\PYG{l+m+mf}{0.001}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} pause a bit so that plots are updated}


\PYG{c+c1}{\PYGZsh{} initialize custom dataset}
\PYG{n}{face\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{FaceLandmarksDataset}\PYG{p}{(}\PYG{n}{csv\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{faces/face\PYGZus{}landmarks.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                    \PYG{n}{root\PYGZus{}dir}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{faces/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} initialite the custom dataloader}
\PYG{n}{dataloader} \PYG{o}{=} \PYG{n}{AugmentDataLoader}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{n}{face\PYGZus{}dataset}\PYG{p}{,}
                               \PYG{n}{batch\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}
                               \PYG{n}{shuffle}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
                               \PYG{n}{pipeline\PYGZus{}operations}\PYG{o}{=}\PYG{p}{(}
                                   \PYG{n}{TranslatePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{translation}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                   \PYG{n}{VflipPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,}
                                   \PYG{n}{HflipPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,}
                                   \PYG{n}{ContrastPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{contrast\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                                   \PYG{n}{RandomShearPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{shear\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                               \PYG{n}{resize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{)}\PYG{p}{,}
                               \PYG{c+c1}{\PYGZsh{} we must indicate the size of the resize because the images are not all the same size}
                               \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bilinear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                               \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zeros}\PYG{l+s+s1}{\PYGZsq{}}
                               \PYG{p}{)}

\PYG{n}{number\PYGZus{}of\PYGZus{}iterations} \PYG{o}{=} \PYG{l+m+mi}{3}  \PYG{c+c1}{\PYGZsh{} number of times the entire dataset is processed}
\PYG{k}{for} \PYG{n}{epoch} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}iterations} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i\PYGZus{}batch}\PYG{p}{,} \PYG{n}{sample\PYGZus{}batched} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{dataloader}\PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} our dataloader works like a normal dataloader}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i\PYGZus{}batch}\PYG{p}{,} \PYG{p}{)}
        \PYG{n}{keypoints} \PYG{o}{=} \PYG{n}{sample\PYGZus{}batched}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{keypoints}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
        \PYG{n}{show\PYGZus{}landmarks}\PYG{p}{(}\PYG{n}{sample\PYGZus{}batched}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{keypoints}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all elements of the original dataset have been displayed and processed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Image Augmentation to Disk example}
\label{\detokenize{augment_to_disk_example:image-augmentation-to-disk-example}}\label{\detokenize{augment_to_disk_example::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{from} \PYG{n+nn}{skimage} \PYG{k+kn}{import} \PYG{n}{io}
\PYG{k+kn}{from} \PYG{n+nn}{torch}\PYG{n+nn}{.}\PYG{n+nn}{utils}\PYG{n+nn}{.}\PYG{n+nn}{data} \PYG{k+kn}{import} \PYG{n}{Dataset}

\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{pipeline\PYGZus{}geometric\PYGZus{}ops} \PYG{k+kn}{import} \PYG{n}{RandomScalePipeline}\PYG{p}{,} \PYG{n}{HflipPipeline}
\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{pipeline\PYGZus{}pixel\PYGZus{}ops} \PYG{k+kn}{import} \PYG{n}{RandomContrastPipeline}
\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{image\PYGZus{}augmentation}\PYG{n+nn}{.}\PYG{n+nn}{augment\PYGZus{}to\PYGZus{}disk} \PYG{k+kn}{import} \PYG{n}{AugmentToDisk}


\PYG{c+c1}{\PYGZsh{} Create custom dataset to read the input data to be augmented}
\PYG{k}{class} \PYG{n+nc}{FaceLandmarksDataset}\PYG{p}{(}\PYG{n}{Dataset}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Face Landmarks dataset.\PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{csv\PYGZus{}file}\PYG{p}{,} \PYG{n}{root\PYGZus{}dir}\PYG{p}{,} \PYG{n}{transform}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            csv\PYGZus{}file (string): Path to the csv file with annotations.}
\PYG{l+s+sd}{            root\PYGZus{}dir (string): Directory with all the images.}
\PYG{l+s+sd}{            transform (callable, optional): Optional transform to be applied}
\PYG{l+s+sd}{                on a sample.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{landmarks\PYGZus{}frame} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{csv\PYGZus{}file}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{root\PYGZus{}dir} \PYG{o}{=} \PYG{n}{root\PYGZus{}dir}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{transform} \PYG{o}{=} \PYG{n}{transform}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}len\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{landmarks\PYGZus{}frame}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{idx}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{is\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{idx}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{idx} \PYG{o}{=} \PYG{n}{idx}\PYG{o}{.}\PYG{n}{tolist}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{img\PYGZus{}name} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{root\PYGZus{}dir}\PYG{p}{,}
                                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{landmarks\PYGZus{}frame}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{item\PYGZus{}id} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{landmarks\PYGZus{}frame}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{image} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{n}{img\PYGZus{}name}\PYG{p}{)}
        \PYG{n}{landmarks} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{landmarks\PYGZus{}frame}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
        \PYG{n}{landmarks} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{landmarks}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{landmarks} \PYG{o}{=} \PYG{n}{landmarks}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{float}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n}{sample} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{item\PYGZus{}id}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{image}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{landmarks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{landmarks}\PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{sample}


\PYG{c+c1}{\PYGZsh{} Inicialize the custom datset}

\PYG{n}{face\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{FaceLandmarksDataset}\PYG{p}{(}\PYG{n}{csv\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{faces/face\PYGZus{}landmarks.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                    \PYG{n}{root\PYGZus{}dir}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{faces/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} parameter setting and initialization}

\PYG{n}{augmentor} \PYG{o}{=} \PYG{n}{AugmentToDisk}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{n}{face\PYGZus{}dataset}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} custom dataset that provides the input data}
                          \PYG{n}{samples\PYGZus{}per\PYGZus{}item}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} number of samples per imput item}
                          \PYG{n}{operations}\PYG{o}{=}\PYG{p}{(}\PYG{n}{RandomScalePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{n}{scale\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{center\PYGZus{}deviation}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
                                     \PYG{n}{HflipPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,}
                                     \PYG{n}{RandomContrastPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{contrast\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                          \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nearest}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                          \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zeros}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                          \PYG{n}{resize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{250}\PYG{p}{,} \PYG{l+m+mi}{250}\PYG{p}{)}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Here resizing is necessary because the input images have different sizes}
                          \PYG{n}{output\PYGZus{}extension}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.jpg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                          \PYG{n}{output\PYGZus{}csv\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{anotations.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                          \PYG{n}{output\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./augmented\PYGZus{}custom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{augmentor}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Run the augmentation}
\end{sphinxVerbatim}


\subsubsection{Neural Net example}
\label{\detokenize{neural_net_example:neural-net-example}}\label{\detokenize{neural_net_example::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}

\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{n+nn}{.}\PYG{n+nn}{path}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{torch}\PYG{n+nn}{.}\PYG{n+nn}{optim} \PYG{k}{as} \PYG{n+nn}{optim}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{torch}\PYG{n+nn}{.}\PYG{n+nn}{nn} \PYG{k}{as} \PYG{n+nn}{nn}
\PYG{k+kn}{import} \PYG{n+nn}{torch}\PYG{n+nn}{.}\PYG{n+nn}{nn}\PYG{n+nn}{.}\PYG{n+nn}{functional} \PYG{k}{as} \PYG{n+nn}{F}

\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{pipeline\PYGZus{}geometric\PYGZus{}ops} \PYG{k+kn}{import} \PYG{n}{HflipPipeline}\PYG{p}{,} \PYG{n}{RandomShearPipeline}\PYG{p}{,} \PYGZbs{}
    \PYG{n}{RandomRotatePipeline}
\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{pipeline\PYGZus{}pixel\PYGZus{}ops} \PYG{k+kn}{import} \PYG{n}{NormalizePipeline}\PYG{p}{,} \PYG{n}{RandomContrastPipeline}
\PYG{k+kn}{from} \PYG{n+nn}{ida\PYGZus{}lib}\PYG{n+nn}{.}\PYG{n+nn}{image\PYGZus{}augmentation}\PYG{n+nn}{.}\PYG{n+nn}{data\PYGZus{}loader} \PYG{k+kn}{import} \PYG{n}{AugmentDataLoader}

\PYG{k+kn}{import} \PYG{n+nn}{kornia}
\PYG{k}{if} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{version\PYGZus{}info}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{cPickle} \PYG{k}{as} \PYG{n+nn}{pickle}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{pickle}

\PYG{k+kn}{import} \PYG{n+nn}{torch}\PYG{n+nn}{.}\PYG{n+nn}{utils}\PYG{n+nn}{.}\PYG{n+nn}{data} \PYG{k}{as} \PYG{n+nn}{data}
\PYG{k+kn}{from} \PYG{n+nn}{torchvision}\PYG{n+nn}{.}\PYG{n+nn}{datasets}\PYG{n+nn}{.}\PYG{n+nn}{utils} \PYG{k+kn}{import} \PYG{n}{download\PYGZus{}url}\PYG{p}{,} \PYG{n}{check\PYGZus{}integrity}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}https://pytorch.org/tutorials/beginner/blitz/cifar10\PYGZus{}tutorial.html\PYGZsh{}define\PYGZhy{}a\PYGZhy{}convolutional\PYGZhy{}neural\PYGZhy{}network\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} create a custom cifar Dataset to read the data}
\PYG{k}{class} \PYG{n+nc}{custom\PYGZus{}CIFAR10}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}`CIFAR10 \PYGZlt{}https://www.cs.toronto.edu/\PYGZti{}kriz/cifar.html\PYGZgt{}`\PYGZus{} Dataset.}

\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        root (string): Root directory of dataset where directory}
\PYG{l+s+sd}{            ``cifar\PYGZhy{}10\PYGZhy{}batches\PYGZhy{}py`` exists.}
\PYG{l+s+sd}{        train (bool, optional): If True, creates dataset from training set, otherwise}
\PYG{l+s+sd}{            creates from test set.}
\PYG{l+s+sd}{        transform (callable, optional): A function/transform that  takes in an PIL image}
\PYG{l+s+sd}{            and returns a transformed version. E.g, ``transforms.RandomCrop``}
\PYG{l+s+sd}{        target\PYGZus{}transform (callable, optional): A function/transform that takes in the}
\PYG{l+s+sd}{            target and transforms it.}
\PYG{l+s+sd}{        download (bool, optional): If true, downloads the dataset from the internet and}
\PYG{l+s+sd}{            puts it in root directory. If dataset is already downloaded, it is not}
\PYG{l+s+sd}{            downloaded again.}

\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{base\PYGZus{}folder} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cifar\PYGZhy{}10\PYGZhy{}batches\PYGZhy{}py}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{url} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http://www.cs.toronto.edu/\PYGZti{}kriz/cifar\PYGZhy{}10\PYGZhy{}python.tar.gz}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{filename} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cifar\PYGZhy{}10\PYGZhy{}python.tar.gz}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{tgz\PYGZus{}md5} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c58f30108f718f92721af3b95e74349a}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{train\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}
        \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data\PYGZus{}batch\PYGZus{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c99cafc152244af753f735de768cd75f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data\PYGZus{}batch\PYGZus{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d4bba439e000b95fd0a9bffe97cbabec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data\PYGZus{}batch\PYGZus{}3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{54ebc095f3ab1f0389bbae665268c751}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data\PYGZus{}batch\PYGZus{}4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{634d18415352ddfa80567beed471001a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data\PYGZus{}batch\PYGZus{}5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{482c414d41f54cd18b22e5b47cb7c3cb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{]}

    \PYG{n}{test\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}
        \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test\PYGZus{}batch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{40351d587109b95175f43aff81a1287e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{]}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{root}\PYG{p}{,} \PYG{n}{train}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
                 \PYG{n}{transform}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{target\PYGZus{}transform}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
                 \PYG{n}{download}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{root} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{expanduser}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{transform} \PYG{o}{=} \PYG{n}{transform}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{target\PYGZus{}transform} \PYG{o}{=} \PYG{n}{target\PYGZus{}transform}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train} \PYG{o}{=} \PYG{n}{train}  \PYG{c+c1}{\PYGZsh{} training set or test set}

        \PYG{k}{if} \PYG{n}{download}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{download}\PYG{p}{(}\PYG{p}{)}

        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}check\PYGZus{}integrity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{RuntimeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dataset not found or corrupted.}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+}
                               \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ You can use download=True to download it}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} now load the picked numpy arrays}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}labels} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{fentry} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}list}\PYG{p}{:}
                \PYG{n}{f} \PYG{o}{=} \PYG{n}{fentry}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
                \PYG{n}{file} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{base\PYGZus{}folder}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}
                \PYG{n}{fo} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{file}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{k}{if} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{version\PYGZus{}info}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{:}
                    \PYG{n}{entry} \PYG{o}{=} \PYG{n}{pickle}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{fo}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                    \PYG{n}{entry} \PYG{o}{=} \PYG{n}{pickle}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{fo}\PYG{p}{,} \PYG{n}{encoding}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latin1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{entry}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
                \PYG{k}{if} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{entry}\PYG{p}{:}
                    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}labels} \PYG{o}{+}\PYG{o}{=} \PYG{n}{entry}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                \PYG{k}{else}\PYG{p}{:}
                    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}labels} \PYG{o}{+}\PYG{o}{=} \PYG{n}{entry}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fine\PYGZus{}labels}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                \PYG{n}{fo}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}data}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}data} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}data}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{50000}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{)}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}data} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}data}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} convert to HWC}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{f} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
            \PYG{n}{file} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{base\PYGZus{}folder}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}
            \PYG{n}{fo} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{file}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{k}{if} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{version\PYGZus{}info}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{:}
                \PYG{n}{entry} \PYG{o}{=} \PYG{n}{pickle}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{fo}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{entry} \PYG{o}{=} \PYG{n}{pickle}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{fo}\PYG{p}{,} \PYG{n}{encoding}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latin1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}data} \PYG{o}{=} \PYG{n}{entry}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
            \PYG{k}{if} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{entry}\PYG{p}{:}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}labels} \PYG{o}{=} \PYG{n}{entry}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}labels} \PYG{o}{=} \PYG{n}{entry}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fine\PYGZus{}labels}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
            \PYG{n}{fo}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}data} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}data}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{)}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}data} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}data}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} convert to HWC}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{index}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            index (int): Index}

\PYG{l+s+sd}{        Returns:}
\PYG{l+s+sd}{            tuple: (image, target) where target is index of the target class.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train}\PYG{p}{:}
            \PYG{n}{img}\PYG{p}{,} \PYG{n}{target} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}data}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}labels}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{img}\PYG{p}{,} \PYG{n}{target} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}data}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}labels}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}

        \PYG{n}{item} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{img}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{target}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{target}\PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{item}  \PYG{c+c1}{\PYGZsh{} modified to return a dict instead of a tuple}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}len\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}data}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}data}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}check\PYGZus{}integrity}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{root} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{root}
        \PYG{k}{for} \PYG{n}{fentry} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{train\PYGZus{}list} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{test\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{filename}\PYG{p}{,} \PYG{n}{md5} \PYG{o}{=} \PYG{n}{fentry}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{fentry}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
            \PYG{n}{fpath} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{base\PYGZus{}folder}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}
            \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{check\PYGZus{}integrity}\PYG{p}{(}\PYG{n}{fpath}\PYG{p}{,} \PYG{n}{md5}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{return} \PYG{k+kc}{False}
        \PYG{k}{return} \PYG{k+kc}{True}

    \PYG{k}{def} \PYG{n+nf}{download}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k+kn}{import} \PYG{n+nn}{tarfile}

        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}check\PYGZus{}integrity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Files already downloaded and verified}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{k}{return}

        \PYG{n}{root} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{root}
        \PYG{n}{download\PYGZus{}url}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{url}\PYG{p}{,} \PYG{n}{root}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{filename}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{tgz\PYGZus{}md5}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} extract file}
        \PYG{n}{cwd} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{tar} \PYG{o}{=} \PYG{n}{tarfile}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r:gz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{os}\PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
        \PYG{n}{tar}\PYG{o}{.}\PYG{n}{extractall}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{tar}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{os}\PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{n}{cwd}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}auxiliar function to plot batches images}
\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}tuple\PYGZus{}batch}\PYG{p}{(}\PYG{n}{images}\PYG{p}{,} \PYG{n}{labels}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{images}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{images} \PYG{o}{=} \PYG{n}{images}\PYG{o}{.}\PYG{n}{cpu}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{labels} \PYG{o}{=} \PYG{n}{labels}\PYG{o}{.}\PYG{n}{cpu}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{batch\PYGZus{}size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{axs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{axs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{n}{classes}\PYG{p}{[}\PYG{n}{labels}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{img}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray} \PYG{o}{=} \PYG{n}{kornia}\PYG{o}{.}\PYG{n}{tensor\PYGZus{}to\PYGZus{}image}\PYG{p}{(}\PYG{p}{(}\PYG{n}{images}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mi}{255}\PYG{p}{)}\PYG{o}{.}\PYG{n}{byte}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{axs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} initialize train dataset}
\PYG{n}{trainset} \PYG{o}{=} \PYG{n}{custom\PYGZus{}CIFAR10}\PYG{p}{(}\PYG{n}{root}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{train}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
                          \PYG{n}{download}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} define the cnn model}
\PYG{k}{class} \PYG{n+nc}{Net}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{Module}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{Net}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{conv1} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Conv2d}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{pool} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{MaxPool2d}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{conv2} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Conv2d}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc1} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{16} \PYG{o}{*} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{120}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc2} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{120}\PYG{p}{,} \PYG{l+m+mi}{84}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc3} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{84}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{x} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{pool}\PYG{p}{(}\PYG{n}{F}\PYG{o}{.}\PYG{n}{relu}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{conv1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{x} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{pool}\PYG{p}{(}\PYG{n}{F}\PYG{o}{.}\PYG{n}{relu}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{conv2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{x} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{view}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{16} \PYG{o}{*} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{)}
        \PYG{n}{x} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{relu}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{x} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{relu}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{x} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fc3}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{x}

\PYG{c+c1}{\PYGZsh{} def train loop}
\PYG{k}{def} \PYG{n+nf}{train}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{net} \PYG{o}{=} \PYG{n}{Net}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{net} \PYG{o}{=} \PYG{n}{net}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Configure parameters}
    \PYG{n}{criterion} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{CrossEntropyLoss}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{optim}\PYG{o}{.}\PYG{n}{SGD}\PYG{p}{(}\PYG{n}{net}\PYG{o}{.}\PYG{n}{parameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lr}\PYG{o}{=}\PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{n}{momentum}\PYG{o}{=}\PYG{l+m+mf}{0.9}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} TRAIN}
    \PYG{k+kn}{from} \PYG{n+nn}{time} \PYG{k+kn}{import} \PYG{n}{time}
    \PYG{n}{start\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{epoch} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} loop over the dataset multiple times}
        \PYG{n}{running\PYGZus{}loss} \PYG{o}{=} \PYG{l+m+mf}{0.0}
        \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{data} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{trainloader}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} get the inputs; data is a list of [inputs, labels]}
            \PYG{n}{inputs}\PYG{p}{,} \PYG{n}{labels} \PYG{o}{=} \PYG{n}{data}
            \PYG{n}{inputs} \PYG{o}{=} \PYG{p}{(}\PYG{n}{inputs}\PYG{o}{.}\PYG{n}{float}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{labels} \PYG{o}{=} \PYG{n}{labels}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cuda}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{zero\PYGZus{}grad}\PYG{p}{(}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} forward + backward + optimize}
            \PYG{n}{outputs} \PYG{o}{=} \PYG{n}{net}\PYG{p}{(}\PYG{n}{inputs}\PYG{p}{)}
            \PYG{n}{loss} \PYG{o}{=} \PYG{n}{criterion}\PYG{p}{(}\PYG{n}{outputs}\PYG{p}{,} \PYG{n}{labels}\PYG{p}{)}
            \PYG{n}{loss}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{step}\PYG{p}{(}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} print statistics}
            \PYG{n}{running\PYGZus{}loss} \PYG{o}{+}\PYG{o}{=} \PYG{n}{loss}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}
            \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2000} \PYG{o}{==} \PYG{l+m+mi}{1999}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} print every 2000 mini\PYGZhy{}batches}
                \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{, }\PYG{l+s+si}{\PYGZpc{}5d}\PYG{l+s+s1}{] loss: }\PYG{l+s+si}{\PYGZpc{}.3f}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}}
                      \PYG{p}{(}\PYG{n}{epoch} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{running\PYGZus{}loss} \PYG{o}{/} \PYG{l+m+mi}{2000}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{running\PYGZus{}loss} \PYG{o}{=} \PYG{l+m+mf}{0.0}
    \PYG{n}{consumed\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}time}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{consumed\PYGZus{}time}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Finished Training}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{torch}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{net}\PYG{o}{.}\PYG{n}{state\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{PATH}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}def test loop}
\PYG{k}{def} \PYG{n+nf}{test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{images}\PYG{p}{,} \PYG{n}{labels} \PYG{o}{=} \PYG{n}{dataiter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} print images}
    \PYG{n}{plot\PYGZus{}tuple\PYGZus{}batch}\PYG{p}{(}\PYG{n}{images}\PYG{p}{,} \PYG{n}{labels}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GroundTruth: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}5s}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{classes}\PYG{p}{[}\PYG{n}{labels}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{net} \PYG{o}{=} \PYG{n}{Net}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{net} \PYG{o}{=} \PYG{n}{net}\PYG{o}{.}\PYG{n}{cuda}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{net}\PYG{o}{.}\PYG{n}{load\PYGZus{}state\PYGZus{}dict}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{PATH}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{outputs} \PYG{o}{=} \PYG{n}{net}\PYG{p}{(}\PYG{n}{images}\PYG{p}{)}
    \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{predicted} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{outputs}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Predicted: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}5s}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{classes}\PYG{p}{[}\PYG{n}{predicted}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}
                                  \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{class\PYGZus{}correct} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{l+m+mf}{0.} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{class\PYGZus{}total} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{l+m+mf}{0.} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{with} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{no\PYGZus{}grad}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{data} \PYG{o+ow}{in} \PYG{n}{testloader}\PYG{p}{:}
            \PYG{n}{images}\PYG{p}{,} \PYG{n}{labels} \PYG{o}{=} \PYG{n}{data}
            \PYG{n}{labels} \PYG{o}{=} \PYG{n}{labels}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cuda}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{n}{outputs} \PYG{o}{=} \PYG{n}{net}\PYG{p}{(}\PYG{n}{images}\PYG{p}{)}
            \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{predicted} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{outputs}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n}{c} \PYG{o}{=} \PYG{p}{(}\PYG{n}{predicted} \PYG{o}{==} \PYG{n}{labels}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{label} \PYG{o}{=} \PYG{n}{labels}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
                \PYG{n}{class\PYGZus{}correct}\PYG{p}{[}\PYG{n}{label}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}
                \PYG{n}{class\PYGZus{}total}\PYG{p}{[}\PYG{n}{label}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Accuracy of }\PYG{l+s+si}{\PYGZpc{}5s}\PYG{l+s+s1}{ : }\PYG{l+s+si}{\PYGZpc{}2d}\PYG{l+s+s1}{ }\PYG{l+s+si}{\PYGZpc{}\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}
            \PYG{n}{classes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{100} \PYG{o}{*} \PYG{n}{class\PYGZus{}correct}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{/} \PYG{n}{class\PYGZus{}total}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create the dataloader with ida\PYGZus{}lib augmentations}
\PYG{n}{trainloader} \PYG{o}{=} \PYG{n}{AugmentDataLoader}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{n}{trainset}\PYG{p}{,}
                                \PYG{n}{batch\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}
                                \PYG{n}{shuffle}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
                                \PYG{n}{resize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{)}\PYG{p}{,}
                                \PYG{n}{pipeline\PYGZus{}operations}\PYG{o}{=}\PYG{p}{(}\PYG{n}{NormalizePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                                                     \PYG{n}{HflipPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                                                     \PYG{n}{RandomRotatePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{degrees\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                                     \PYG{n}{RandomContrastPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{contrast\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                                     \PYG{n}{RandomShearPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{shear\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bilinear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zeros}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                \PYG{n}{output\PYGZus{}format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tuple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                \PYG{n}{output\PYGZus{}type}\PYG{o}{=}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{float32}
                                \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} initialize test dataset}
\PYG{n}{testset} \PYG{o}{=} \PYG{n}{custom\PYGZus{}CIFAR10}\PYG{p}{(}\PYG{n}{root}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{train}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
                         \PYG{n}{download}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create the dataloader with ida\PYGZus{}lib augmentations}
\PYG{n}{testloader} \PYG{o}{=} \PYG{n}{AugmentDataLoader}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{n}{testset}\PYG{p}{,}
                               \PYG{n}{batch\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}
                               \PYG{n}{shuffle}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
                               \PYG{n}{pipeline\PYGZus{}operations}\PYG{o}{=}\PYG{p}{(}\PYG{n}{NormalizePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                                                    \PYG{n}{HflipPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,}
                                                    \PYG{n}{RandomRotatePipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{n}{degrees\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                                    \PYG{n}{RandomContrastPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{contrast\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                                                    \PYG{n}{RandomShearPipeline}\PYG{p}{(}\PYG{n}{probability}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{shear\PYGZus{}range}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                               \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bilinear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                               \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zeros}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                               \PYG{n}{output\PYGZus{}format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tuple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                               \PYG{n}{output\PYGZus{}type}\PYG{o}{=}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{float32}
                               \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} clases}
\PYG{n}{classes} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{plane}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{car}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bird}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
           \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{deer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{frog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{horse}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ship}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{truck}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} path to save weights}
\PYG{n}{PATH} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./cifar\PYGZus{}net2.pth}\PYG{l+s+s1}{\PYGZsq{}}


\PYG{c+c1}{\PYGZsh{} get some random training images}
\PYG{n}{dataiter} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n}{trainloader}\PYG{p}{)}
\PYG{n}{images}\PYG{p}{,} \PYG{n}{labels} \PYG{o}{=} \PYG{n}{dataiter}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot some items of train}
\PYG{n}{plot\PYGZus{}tuple\PYGZus{}batch}\PYG{p}{(}\PYG{n}{images}\PYG{p}{,} \PYG{n}{labels}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} train the net}
\PYG{n}{train}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} test the results}
\PYG{n}{test}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\section{Built with}
\label{\detokenize{index:built-with}}\begin{itemize}
\item {} 
\sphinxhref{https://pytorch.org/}{Pytorch}.  \sphinxhyphen{} The machine learning framework used

\end{itemize}
\begin{itemize}
\item {} 
\sphinxhref{https://bokeh.org/}{Bokeh}. \sphinxhyphen{} The visualization library used

\end{itemize}
\begin{itemize}
\item {} 
\sphinxhref{https://kornia.github.io/}{Kornia}.  \sphinxhyphen{} computer vision library that is used as a base for transformations

\end{itemize}
\begin{itemize}
\item {} 
\sphinxhref{https://bokeh.org/}{OpenCV}.  \sphinxhyphen{} computer vision library that is used as a base for transformations

\end{itemize}
\begin{itemize}
\item {} 
\sphinxhref{https://www.jetbrains.com/es-es/pycharm/}{Pycharm}. \sphinxhyphen{} Development IDE

\end{itemize}


\section{Acknowledgements}
\label{\detokenize{index:acknowledgements}}\begin{itemize}
\item {} 
\sphinxstylestrong{Nicolás Vila Blanco} : project co\sphinxhyphen{}author

\item {} 
\sphinxstylestrong{María José Carreira Nouche}: project co\sphinxhyphen{}author

\item {} 
\sphinxstylestrong{CITiUS}: support company

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{i}
\item\relax\sphinxstyleindexentry{ida\_lib.core}\sphinxstyleindexpageref{ida_lib.core:\detokenize{module-ida_lib.core}}
\item\relax\sphinxstyleindexentry{ida\_lib.core.pipeline}\sphinxstyleindexpageref{ida_lib.core:\detokenize{module-ida_lib.core.pipeline}}
\item\relax\sphinxstyleindexentry{ida\_lib.core.pipeline\_functional}\sphinxstyleindexpageref{ida_lib.core:\detokenize{module-ida_lib.core.pipeline_functional}}
\item\relax\sphinxstyleindexentry{ida\_lib.core.pipeline\_geometric\_ops}\sphinxstyleindexpageref{ida_lib.core:\detokenize{module-ida_lib.core.pipeline_geometric_ops}}
\item\relax\sphinxstyleindexentry{ida\_lib.core.pipeline\_local\_ops}\sphinxstyleindexpageref{ida_lib.core:\detokenize{module-ida_lib.core.pipeline_local_ops}}
\item\relax\sphinxstyleindexentry{ida\_lib.core.pipeline\_operations}\sphinxstyleindexpageref{ida_lib.core:\detokenize{module-ida_lib.core.pipeline_operations}}
\item\relax\sphinxstyleindexentry{ida\_lib.core.pipeline\_pixel\_ops}\sphinxstyleindexpageref{ida_lib.core:\detokenize{module-ida_lib.core.pipeline_pixel_ops}}
\item\relax\sphinxstyleindexentry{ida\_lib.image\_augmentation}\sphinxstyleindexpageref{ida_lib.image_augmentation:\detokenize{module-ida_lib.image_augmentation}}
\item\relax\sphinxstyleindexentry{ida\_lib.image\_augmentation.augment\_to\_disk}\sphinxstyleindexpageref{ida_lib.image_augmentation:\detokenize{module-ida_lib.image_augmentation.augment_to_disk}}
\item\relax\sphinxstyleindexentry{ida\_lib.image\_augmentation.data\_loader}\sphinxstyleindexpageref{ida_lib.image_augmentation:\detokenize{module-ida_lib.image_augmentation.data_loader}}
\item\relax\sphinxstyleindexentry{ida\_lib.operations}\sphinxstyleindexpageref{ida_lib.operations:\detokenize{module-ida_lib.operations}}
\item\relax\sphinxstyleindexentry{ida\_lib.operations.geometry\_ops\_functional}\sphinxstyleindexpageref{ida_lib.operations:\detokenize{module-ida_lib.operations.geometry_ops_functional}}
\item\relax\sphinxstyleindexentry{ida\_lib.operations.pixel\_ops\_functional}\sphinxstyleindexpageref{ida_lib.operations:\detokenize{module-ida_lib.operations.pixel_ops_functional}}
\item\relax\sphinxstyleindexentry{ida\_lib.operations.transforms}\sphinxstyleindexpageref{ida_lib.operations:\detokenize{module-ida_lib.operations.transforms}}
\item\relax\sphinxstyleindexentry{ida\_lib.operations.utils}\sphinxstyleindexpageref{ida_lib.operations:\detokenize{module-ida_lib.operations.utils}}
\item\relax\sphinxstyleindexentry{ida\_lib.visualization}\sphinxstyleindexpageref{ida_lib:\detokenize{module-ida_lib.visualization}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}